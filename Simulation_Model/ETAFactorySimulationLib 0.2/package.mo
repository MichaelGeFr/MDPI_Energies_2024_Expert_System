package ETAFactorySimulationLib "Modelica models for industrial systems (machines, supply systems, buildings)"
extends ETAFactorySimulationLib.BaseClasses.Icons.ETAFactorySimLib;
  import Modelica.Units.SI;
  import Modelica.Constants;

  package BaseClasses "Package containing base classes for the ETAFactorySimulation library"
    extends ETAFactorySimulationLib.BaseClasses.Icons.Base;

    package Icons
      extends ETAFactorySimulationLib.BaseClasses.Icons.IconsPackage;

      partial package Base "Icon for packages containing base classes"
        extends ETAFactorySimulationLib.BaseClasses.Icons.Package;
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Ellipse(
              extent={{-28,28},{30,-30}},
              lineColor={153,204,0},
              lineThickness=0.5,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),                                   Documentation(info="<html>
<p>This icon indicates a package that contains executable examples.</p>
</html>"));
      end Base;

      class CleaningMach

        annotation (Icon(graphics={Bitmap(
                extent={{-98,-100},{100,100}},
                imageSource=
                    "iVBORw0KGgoAAAANSUhEUgAAAOkAAAD8CAYAAACSLIPLAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAFxEAABcRAcom8z8AABxlSURBVHhe7Z15tF1Vfcez6qpr1VWH+ket2oioUAu1OKAWW7VLsFZF0dIqgoJKGRQBKwgogygyGRHI9MIgkXlIEASRIZi8l5CEkIkEMhEyEiAh80ACIcnp/Z6zv+ftd7NfXt67++z7u8n3y/qs8M49b+/fvu/3PcPev3tuvyo0uL3/1wZ17HP54I59Rg1q32dN7d9MiD0Zl+ej8ryv5b+zgj0NHPOuw2qBzvSDF2IvZSb84KxhQ+7MmQc4pOPvsrb2N2fD2v8qu6b9L2r0E2IP53V5viPvkf/0wqAx+1zuLNJcIRAG1dbx5sAAhNi7gA9Ko9ZOYM4qzZG7xC0M2v7XwYCF2BuBH+iNpl761gLI70F1BhViZ7wz6kxnmbTCLBYCwDV4KEAhRL/Oe9RmzPpysgg3y6HghBC47C3Opk25N611PAqdF7O44QCF2NuBP/Izac0vzjrpxEIFTD+HghNCgNcVZ9KaX5x10skdHQJBCSF86BVnnXSSSYXYPWRSIYwjkwphHJlUCOPIpEIYRyYVwjgyqRDGkUmFMI5MKoRxZFIhjCOTCmEcmVQI48ikQhhHJhXCODKpEMaRSYUwjkwqhHFkUiGMI5MKYRyZVAjjyKRCGEcmFcI4MqkQxpFJhTCOTCqEcWRSIYwjkwphHJlUCOPIpEIYZ6816bD212dDO96SDel4W4131GLpX74ZYm+lf54LyAnkBnIklDupYXzOOunEjkNBVUlb+xtrf4R3lgMXYlcgV5AzoVxKBWNx1kkndhwKqgra2t9Qe8PfXg74xkmfyDrmn59NWTIoW71pbrZl69qMmrq0LRs27h/KfRevHuNesaXlG6Zn9z91XBnnfTO/5V6pTq+8tj67bvwHsjnLR7gtdjVp8ZXZA0+fkG3Y8pzbsmshB5ALU5YMznPjxkn/Wr63yB3kUCi3qoYxOOukEzsOBRWbtvY3lQO9bcpns3kr7nV/lq569qUH8te576/v3y//d8S0I9weNrR56+o8iRinz7wV97i9qtG4Z39e9nXH1M9nC1c97F6xJRjz2sf+qYwVcfdFyBU/J5BLoRyrEvbtrJNO7DgUVEyGdry1HOSkxb9xb/3O6ph/QbnfFX/cL/vB+Z/Ovn70V7IrH35vvm3m8ze6PZurNS/PryXfgWWs513z4eyb3z08O+PyQ/Kfb37i027P+Fq2dmKXxCePzj1jt89WqYSYEBsPtKCRKwDkDttBToVyrSrYr7NOOrHjUFCx8M+gc5ePdG93WMvWTij3Pf60/8iOPPLInNN/8cl8228nfCh7ddtGt3dz9adZJ+YxXTriH8s4wYD79s+3P7HkardnXN3z5Nfz9i8cflDe33nDPpz/TGBiC8LZHfFcPeq9+d8S+GbFJXBfNHf53WUbKc+o7NNZJ53YcSioGOD+gX3gzd0dPTr3zHz/X9z8gS7Jf+mIA/Ltjy24yO3ZXK3cNLsc20lnHlrG+f1z/z3fNmTsvtHPbH7iH3fy58s+z7n6Y/l23L/hftWCeDBBbIwTV0XYBp5c9lu3Z++Fgz3bSXWPyv6cddKJHYeCigEniXZ1iVuvDVuW1RL8PfnvnVJLeP6BTzzzsPKNWrlxltu7uXpswS/zeOrPpjjAYDsu92IJ5sP9J9o941eHlH0d853Dc9Niu5V7UxgQ8Vz1yHtyYzJWHkxg4EbFS1/kWCj3YoO+gLNOOrHjUFCNgilztI0b/t5q8pKB+e/i0pF/YHDB9R/Kt/f1Uim2tm7bVLsELy43T7/o38o4v/uDz+XbwHNrx7u9GxNmSdEeLhn9xOflrpX3hDPPiMk/mOBylweTWJfknExKsTyDfoCzTjqx41BQjcJ10O5mcXvSLU8Ul43+H/rYE75YvlkLVj7o9myunnr+pjwenDWOOuaIMtYLf3dQvv33T/6P27Pv8mdJTznv02UfJ/340HwbXrNyddHdweSXtxbxxzyYILfQJnItlIMxQT/AWSed2HEoqEZAlQjaxT1SX8U/AMDM6ffO+Ux2+T3vL7c9NPsUt2fzNWJ6ca91zsCPZkd984jsJ4M+WsYJXtr4lNuzb+Is6WUjOy+rYQAmfl+XNmLLP5j4E3/+wST2fTrW2tF21ZVJ6AM466QTOw4F1Qgo50K7WEdsRPfNPDZv51f3dhY1/O7xQ7LZL97p9rChJWvay/gGjn53+f+j5v4wW7dlsdurb8LlI9sDuLzFfSgur/EzLi2tTBZhaYVx4soCZ30cTHBwwTacZWOLa9XIuVAuxoLjctZJJ3YcCqoRUHeJdlE10oiWr59Wvjlg4qIB2fYdr7lXC23d9rL7v+bqkTmnlXGOnP5f2dI1Y90rhTa+8oL7v77JL2AAMAH+bWSWtArhftOvEmKcVc08o1oN7SPnQrkYC47HWSed2HEoqEYoiuX3ycu7GlX7/POyh2efmq3dvMBtKTT/pfuzWycfmrU/c67b0lyt3bwwu2HiwdnTL9zithTa/OrK2hjOzd8PFEH0RvX3mfiZl74As70WzqKhGDjDS6oqYUSOoX3kXCgXY8FxOOukEzsOBdUI/DSLX4vbV23dttn9X6EVG57M7n/qO+WbBl5cP9W92lzVn+WnPXdNds1jxaUe6M19NBIfZ59Q3SuWWvCalcIFGLK7SiIcVGIsuXQn5Fjx/vYP5mIs+Dd01kkndhwKqhHYbkxt2bomG+uVDYLL7i4M8IcERe29EWaeb5/SuQwz4A9FFRJYtPrPbq9di7OkxMrkUL1wMOGSC8DZPfXBg32HcjEW7MNZJ52qGhzbjSkU2LPd86/9UPbN4w/PJ1AGtxfbqi5q313hrM44rx71nuzUn30qn+E8+6piIf+uaV9ye3Yvf5YU5X9sr5G616rEe2VODhGcQWPP5HYn9hnKxViwD2eddKpqcGw3phasfKhs99gTv1BO76coau+t7plxVB7TuW0fKeP8+je+kl35ULGYP2PZcLdnWLzvZH0uljD8ulcrk0U4Y9Yvufi1xDiopBD7C+ViLNiHs046VTU4thtbLGq/4LcfLJMflEXti6spau+tnl/3ePkeHH/q58o4T/t58UGB68cf1O2ET3f1uSjqwPaqZkn7ovpif4AlFx5QqlhyCQl9gVAuxoJ9OOukU1WDY7uxtaqnovaOfbP1iS6xetLoeWflMV10S9cPClxyV/FBgdA9JszXXWE6S+qsnEUtHUzQHwjlYizYh7NOOlU1OLZbhVIWtTcirIsOHfu+PKZTzvM+KHBG5wcF6iuRuGxRZWF6DMF8lor90R8I5WIs2IezTjpVNTi2W4W6K2o/+ezPlP3GKmpvVCjmQDy/vn//7Mj/LuIEl/++KG/849PHuz27zpL648K9HsdlZcnFWrE/359QLsaCfTjrpFNVg2O7Vckvaj/6uC/lNbPsE8x68Q63Z/N16+Ti4HHmgEPyA8llzqAAxffrtyzN9/OXXPzEZ32ulSsEf+bZvyRvZrE/37dQLsaCfTjrpFNVg2O7VWqkK2ofOHrfsr9H5pyerdu8yO1hQ8+8dF8ZHxn++MdrB5Lb3R6F/LI/1r1WWZjeV+FszjgBzp64J21msT9jCeViLNiHs046VTU4tlul/KL2kdO/Wvu5w71SaPXLz2Tbd2xzPzVX9z/17TLWCQsvz7Ztf9W9UuiF9ZPzf1lJxH1JqlnS3ojLRD64XG/GzDP7D+ViLNiHs046VTU4tlu1xjxzTu3S92b3U6HNW1dlHfPPy/ufsPAyt7W5Wr7hyeyh2d/P1tQOHL7wZMSbJ30qf3TppldXuK1d614tLbnU3xPX1xI3a+aZ/YdyMRbsw1knnaoaHNutWtt3bHX/V2j6c9dl1zxWLHEQnFGtCbO6mDTy47xnRteZWxgTBrBSYcQDB2IK1RJje7MOJnwPQ7kYC/bhrJNOVQ2O7abSglqS3DHlP8t+L77jwHIGFWcwK9q2/ZUu9571oGrKyhMWfMF89Zfhzbj37E6MKZSLsWAfzjrpVNXg2G4K7aj9xwS6+tHOWllMZjCORasfdXs3V/gYG2NClQ5qe/H/fikdCJ2tmil/yaW+7M/CmZ7xhHIxFuzDWSedqhoc202lOcvvyvsbNObd2dHHfblcFuhNUXsq3Tn1C3lMKMbAv5gVZby+AaycqfwlF8w2I06/lhhGbfbZn+9ZKBdjwT6cddKpqsGx3ZRiUftPhxxcJn1vitpTaeGqR8r3B/jPAuIjUWAKK5NFnBiqr8+t8pEovRXfy1AuxoJ9OOukU1WDY7sp5Re1fzdQ1H5dXtS+zu3dXOFJ/IipPvH5qJH6SaRmqVWK/RELCOViLNiHs046VTU4tptafSlqTy0m/lW1+1HUutYnPlm/ZYn7jeYI5uup2N/KzDPfs1AuxoJ9OOukU1WDY7uphaL2tkBR+08GH1zG1OjjNRsREr+7wnSeRa94oIh/1Nz/c7/VHLVKsT+EeEAoF2PBPpx10qmqwbHdZsgvaj/5rM+Uj1gBd08/sqlnKL8+178XxWUvt5PHFw3IduzY7n4zrXAwYbG//6xfi8X+EGMK5WIs2IezTjpVNTi22yyxqJ0Mn/jR7OkXbnWvNk+4PPTjwmwuJ4vIw3N2fjJiamFGlxNGgLXE1or9KcYZysVYsA9nnXSqanBst1nyi9onLLw0e237FvdKoWbfS/kGIHgcaP23ma/YMKN2xprgfkqvUC2xpWJ/irGFcjEW7MNZJ52qGhzbbaYmLvpVtvrlee6nQs+u/FN2+5Tikm3q0qFua/XCOmKo7hWfu0QsqN31Z0nxmEo+GfGG2lXAa9u7Pta0SoXqb/1aYovF/owtlIuxYB/OOulU1eDYrhWt3Ph0zRD/W8YFho3bP9v06nK3R7XiLGmokghndf/MDkPwfpDgaiCFOPMcqiTCQQSz4/7BxIr4PoVyMRbsw1knnaoaHNtttvCRsHELflHGA358xb9kF99efJU+PkVTtfyzEAktBS1cNSq7c2rnt8ZdcueB2Q8v7rzUXL2p61VBbPkzzwQ/W6wlrhfjDeViLNiHs046VTU4ttts4TLx2vHFZAcK7r91wheLWcrTO2cpX1j3hNs7vpD4vKfDJNGu6l75pbhXP7pvdtqFRf0x+NkNH8y3Pzjre27PauTX59ZPZoWuACyJcYZyMRbsw1knnaoaHNu1oCeXXZ/H8psH35d97aivlsmPZ+Ji+70zjnF7xpef+FxrxCwp3x//WUD4oMBNkwpz/OiyT5RxHndSUesLcLatQjiY8BKbz1dCvJzNBZaWXOrFGEO5GAv24ayTTlUNju1aEYvaz7ry42XyH/PtL+UF+dg+d/lIt2c8hQrTwa6eBTSnFgdeQ1yIj7+DuLEd46hCuPxG+36xP2jmI1F6I8QIQrkYC/bhrJNOVQ2O7VqRX9TuP/0eZyxsu2nSJ2t77Sh2jiQus/S2MP3eGUfnr/tPv8cVAK4EsD00+9qI/GcWWS/2706MP5SLsWAfzjrpVNXg2K4lPTjr5Dwm3OMxEQG/oDjm0kIjhem4R8Y+wDcN7lOxDffYMb6tjuLMc3fF/haXXOrF9yuUi7FgH8466VTV4NiuJa1y32MJePn57ZqB/G8R37x1tdu77/JnSf3CdP/B0T0VU4x+5px8P//y84e1MxufjIg11BjyDyahYn8rn3LpSYgVhHIxFuzDWSedqhoc27Wm8QsuyeOCMc92heIExQ87Ijxd0F9ywWwuE783helYv20bV3y/zVm/+Xh2qfeNZaEnI/ZF/sEEE1s84/sHE8uTRb743oRyMRbsw1knnaoaHNu1JizJoPyO8YGHZ/8gW/Pys26PxoXJIL/sD5eN/sfQdjfxURHF3wE3TPzITk9GbFT1a7g4qLDYP/VT6BsR4w/lYizYh7NOOlU1OLZrUXzOEB6psnj1aLe10IqNM/Ov/4+hUN1rb2dJb5tcfG/M+AUXZ1u3vey2Fpr+3LX5A9gaFc6o9bXEoZlny2LcoVyMBftw1kmnqgbHdq0KBvKFJzaMffbCMu6+fGIGSy4hE/Js1ZfC9NW1++hVm+a4nwrhe1r5ZMRbJx/qtvZOmAzaVS2x9SWXevHvFsrFWLAPZ510qmpwbLcVNGPZDdl14/+5jBkURe1dPznTkzhL2l3da/2BobfC1z7y+1kBnoyIf6csHeL22D35Sy7d1RK3wmSRL44nlIuxYB/OOulU1eDYrmXhM5t3Tj28jPWSOw/ITvjRYeU6Zm+K2jlL6hOr7nXbjq3l1z0STCadekFRudQ2br9s4ysvur17Fg8mPq125qwXxxHKxViwD2eddKpqcGzXstZtXlzG+dPBnU8YZEUQ2J2idn+WFBNEobrXRs9MvBS/4oH9uhRjXOQqgkbPO9vtuWvx0huzt1iD9Z8IgSuAVpnNrRfHEMrFWLAPZ510qmpwbNe6WNSOJRkmPuhNUXuoPhf/8rm0MWZJcc/MS3I8/ZBx+o8zeX7dJLd3WDhQsD7Xf74Sl4aATNo97MNZJ52qGhzbta/Gitr9+lwUzvP3aR68Fivxce+MNvEc4a99o/PBYOcO5QcFvuH2DCt0MAGsz22lJZd6IX4QysVYsA9nnXSqanBstxXUc1H7F92eOwv3ctgnVWH6XdOKe2g8mZ994UuUB44uPijQXSVTX4r9W0kYAwjlYizYh7NOOlU1OLbbKuquqB3PxsX2UFG7P0saKkzHpWXsWVJ8pw379GuCf3Rp8UEBrMuGqqa4tNLbYv9WEd+TUC7Ggn0466RTVYNju62iLkXtpxeGg9kG/rmolUVRe/2SDGdJ/dK/FIXp+JY4tE/DHXfS52v30J0TQNOWtrk9C/n1uZafQt+IOPZQLsaCfTjrpFNVg2O7rSQ8SgUx456NX6YERkw7Iluyut3tVchfcsHZiMmfIvHxfavs++c3dl3fDT0ZkTPPgAX/vSn2bwVxfKFcjAX7cNZJp6oGx3ZbSShqx1P7GDu+r2Xm8ze5Vwv5T+0L1b2mKkzHN5j7fT84+3s7PRmR8iuJAM70XHrZnWL/VhDHFsrFWLAPZ510qmpwbLfVxKL2xxZclL26baPbWgiPYfnTrJPcT4Vwtqyve00xS4ovIx4+8WP5pNaiutlnPhmx/pMyOGPW1xK36pJLvTieUC7Ggn0466RTVYNju62o+sd84qkOd7jHr4BbJx+200wofsZlJSaLUs2S1n+nDQ4qOLgwzuETD95lLXGrVxn54phDuRgL9uGsk05VDY7ttrLwIXE+zQHgKX78fxCqe23WMsbM52/Mrp9QFGCAgWM6Y+2ulrjVJ4t8cayhXIwF+3DWSaeqBsd2W1WzXry9HAPAminqev1tpJlnpPVblmYjpn25jOXSuw7ITjzjsGzAH4oPjPvEqiW2KI4xlIuxYB/OOulU1eDYbqsKl5IcA79CkQUKmCHFbC5/BrjX6+3H0GKJ98QD7ts/j5MFCpggQpz1tcShNd9WF8cWysVYsA9nnXSqanBst5U1zhW149MxTHQkfqikrpmzpDibDukoLm/xyRgWKPj1uTArtoE9YcmlXhxbKBdjwT6cddKpqsGx3VYW7tlY1M6iBj/xUWV0lZFnAT2x+Ko8jisfLuKpr8/lk/NbuT53V8LYQCgXY8E+nHXSqarBsd1W14xlw8uxWC9M95dXQsX+w8a9f49ZcqkXxx3KxViwD2eddKpqcGy31YX7zCEdRZmfX5/rf+b0iSVXub2bq/ueOjaPBwcPxgl4MEFxxp4q/i1CuRgL9uGsk05VDY7ttrp6KkwHt03+bP49Ls1UT8X+JMajQC2K4wvlYizYh7NOOlU1OLbbysJyBccBWPfK+lwwdv6F2Wvb0n3Bb3fyq55YS+wX+6M6afHqP7u99zxx7KFcjAX7cNZJp6oGx3ZbXTCq/0wgJD0/vjZ5ySC3lw3V1xLzbH/9+IP2qMKFkDjmUC7Ggn0466RTVYMb3NE/bzfmd5Y0U1i24PecAquF6TDjQ7NPKeMEe+pkEYUcK8baP5iLseD76ayTTuw4FFQjDOl4R94unhu7p2j7jm3l2cp64j+3dlxeYbSnLrn4Qo7hb4KcC+ViLOgVZ510YsehoBphSMfb8nanGLsk3NvUrCqolJqyZLAz6duCuRgLesVZJ53YcSioRhja8Za83Y7557u3UpKqEXIMuYacC+ViLOgVZ510YsehoBphWPvr83ZvnPQJ91ZKUjViEQdyLpSLsaBXnHXSiR2HgmqUIR3vzNuet+Je93ZKUlwht5BjyLVQDsaEXnHWSSd2HAqqUdra35i3fduUz7q3VJLiCrmFHEOuhXIwJvSKs046seNQUDEY0vH2vH08KV6SYorfPoAcC+VebOgVZ510YsehoGLQ1v6GcnBzl490b68kNaa5y+8u8wo5Fsq92LA/Z510YsehoGLR1v6mcoB4cyWpEeFgz3xCboVyrgrYp7NOOrHjUFAxGdrx1nKQuvSV+ipe4gLkVCjXqoL9OuukEzsOBRUb/4yKG37N+kq7K+QKJ4lAyjMoYd/OOunEjkNBVQHuHziZBLDGhcVoVI2gvGtPqfWV+i7kAHIB1WrIDay1M1+Gjv37PIdCuVU1jMFZJ53YcSioKsGUOddRhegJ5EqKZZZdwVicddKJHYeCSgGqRFDOhbrLoii/+PSM2Jvpn+cCcgK5UXUl0e7C+Jx10okdh4ISQnQikwphHJlUCOPIpEIYRyYVwjgyqRDGkUmFMI5MKoRxZFIhjCOTCmEcmVQI48ikQhhHJhXCODKpEMaRSYUwjkwqhHFkUiGMI5MKYRyZVAjjyKRCGEcmFcI4MqkQxpFJhTCOTCqEcWRSIYwjkwphHJlUCOPIpEIYRyYVwjgyqRDGkUmFMI5MKoRxZFIhjCOTCmEcmVQI48ikQhhHJhXCODKpEMaRSYUwjkwqhHFkUiGMI5MKYRyZVAjjyKRCGEcmFcI4MqkQxpFJhTCOTCqEcWRSIYwjkwphHJlUCOPIpEIYRyYVwjgyqRDGkUmFMI5MKoRxZFIhjCOTCmEcmVQI48ikQhhHJhXCODKpEMaRSYUwjkwqhHFkUiGMI5MKYRyZVAjjyKRCGEcmFcI4MqkQxpFJhTCOTCqEcWRSIYwjkwphHJlUCOPIpEIYRyYVwjgyqRDGkUmFMI5MKoRxZFIhjCOTCmEcmVQI48ikQhhHJhXCODKpEMaRSYUwjkwqhHFkUiGMI5MKYRyZVAjjyKRCGEcmFcI4MqkQxpFJhTCOTCqEcWRSIYwjkwphHJlUCOPIpEIYRyYVwjgyqRDGkUmFMI5MKoRxZFIhjFOJSa8Z0++oYWP63VJjXo0NoY6FEH0HvnL+ugV+c9brWbVfOLj2C2NDjQohKqTmO/jPWTGstjH9fsJfGNb+l9nQjr+p8be103T/8nQthIhF/9xf8Bn8Ru/Bh86SXeUbtK39TYEGhRBVAt91a9T8Ete9OLTjLcEGhBDVA//Ri10ufXkPqjOoEM2nPKPWfEmDHpW7tnZNHPoFIUR6yntUzPrm07+1H3DzGtpZCJEe+DE/edb8CZPOK0yKWdzwLwgh0gI/OpPOg0nzQgUtswhhif406QbPpO+q20kI0Ty6mlSXu0IYo/5yVxNHQhijy8SRlmCEsEeXJRi3VqpiBiGMsFMxA1Q7paosUAgDdFsWCKnAXojmUp5B4cHd+SQMrolx81rM+moNVYj49PKjalR+6evuUYUQCRnTb8JOl7i7EmaVMP1bQ49PEaIC4Cvnr108PqVfv/8HzXE/QDjc+lkAAAAASUVORK5CYII=",
                fileName=
                    "modelica://ETAFactorySimulationLib/BaseClasses/Icons/Data/CleaningMach.png")}));

      end CleaningMach;

      partial class Components   "Icon for packages containing components"
        extends ETAFactorySimulationLib.BaseClasses.Icons.Package;

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-66,66},{-14,14}},
                lineColor={153,204,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                radius=5), Rectangle(
                extent={{14,66},{66,14}},
                lineColor={153,204,0},
                fillColor={220,238,168},
                fillPattern=FillPattern.Solid,
                radius=5), Rectangle(
                extent={{14,-14},{66,-66}},
                lineColor={153,204,0},
                fillColor={153,204,0},
                fillPattern=FillPattern.Solid,
                radius=5), Rectangle(
                extent={{-66,-14},{-14,-66}},
                lineColor={153,204,0},
                fillColor={187,221,84},
                fillPattern=FillPattern.Solid,
                radius=5)}),                                                      Documentation(info="<html>
<p>This icon indicates a package that contains executable examples.</p>
</html>"));
      end Components;

      class Core

          extends ETAFactorySimulationLib.BaseClasses.Icons.Package;

        annotation (Icon(graphics={Bitmap(
                extent={{-92,-92},{92,92}},
                imageSource="iVBORw0KGgoAAAANSUhEUgAAAMUAAAC2CAMAAABeULmtAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAzUExURQAAAJ+/AJe/AJq/AJe/AJm/AJe/AJm/AJe/AJnBAJrAAJnAAJrAAJnAAJnAAJnAAJnAAD5OhkYAAAAQdFJOUwAQIDBAUGBwgI+fr7/P3+8jGoKKAAAACXBIWXMAABcRAAAXEQHKJvM/AAAK7ElEQVR4Xu2d7ZarKgyGR6uttrb2/q/2oMYK5E0IjnVYe53n195TxxLJN+D8lEXVjy39M+by6mv6Z9lU19f7/cZiXEb3UU//KZnm6QbquND/fepJvvd7vNL/S6W+z+N0jFxzqoE+ez9LVitnEDRMx5N+uPGgTyb6in5YHM2iMCsP+vHKjX5O3OjHZdH4j3omVP/Gm6eZZ4HmcYsH6fAtvAafd/RZOfQ0Mp+RPnNUbKYcA31YDi2NLGAbZkc/CShvLioaWciq+i3Qp/e7oU8L4hMpAppL40BGgXzx3wNVSqU8hXKE0cJAkQEceSmN8jzUBLZvmUJzwjyVGgvNpK40PhtxmlUKVdZkFBgsFnLsu8RgsZBj30UGiwUcvyEFV3tRIaTgpbulgdMlTLkdhE93wADoLuwiqPU3Hrtvz+PFOHQXF9zqFhjMnX7rl8DCxfGiz3Nh4WK8eyUrN5ljJkOMUbviUVXHU/EM+4NbN4o4pNd5oZtx8nosVXPrhydXzifLk4BavR73rvmNNLJXNAekqukGyS1xIcK2WsCj25uPiLc052lzW1lgRH3ainq4kH1NaHkIVvPWxoTns6FPIXRNFkrOY42rihQvoXiQFWCfFLJxv9/G+kWRQjItbTLokiy0ksZoaooUottRchS6IgstcTO6WlkKuXhQsl66AlI1+MlqSbRgmm30hGUpZC8nJQwOugIxrSk8kdfT7AwNoprEDpsvshRyjqQoMl3BqaiGBCqi+HqkEJdlyEEsk6WQff8OKbZ2O7+tJgV3tZ/VCV+MPRqlmCNdEXPxRhqvB9b0c0zkamdtIrxIIEsht/2yrXteXN4IM0wtXMTLvP7TcGJ8PpSlkOOmUkjRFSFsHS3QKjUXCO0oXuv6pEiyFGI9qqkAXRLAhPC1quJLiQHewqGvTcQqhiKFZBiKo0VSROq0MC6ho8Glaki/XBtqE0FiKFLArQfukWhfTNd4QCEcnZsG7ct9pglBK6eORQztweLorTUPuUeQhHDXWmWYeIl6t3iq6iYbKwp8opudugx0zYYsxGF8HG7ddg/4ZHgacwXDGp+P/jr1SRh5veudhCpTt9cu/tY40sba+exvDRz/DGs2fAemx6zuCrZIcK8o7QRb0J3ocbDkjPvkJ6l71fImib6spxUOxxIbJPajrydo8zjUUuwEy15hXYacJW+90ZK/eL4f9jjtygw7PRtnSsHsU4uDIYk+yyludoGt9eZ8d2L9Qs9Wj4QNROurxOgu6jwnxevHrECV6jGfEzB4opRnksl2UU7GtxfQE897esk+ql5UHwLwlGrxAEjY9wkWjrbD293sQnphL3evUi6oe5itxyn7/rZpoMeod1UQ6XawfUuGq1Pufdf1d7ufhKsTWKEe3QRWDcOGFpvbW9ajVxqlAvWgJkQEjNsD3R0309IqZfB7wXr0yi2dRcCWOnQo26TBx5NWqWRSM3bCo0jJgVZPsUJ5kwZHo2fnM+qCpptrJTVOeDgoPfod/1mjuUrlUg7VMEZ9MmEv7QN29HwKw0SLpYrjDU5qiDYVL7VcdOgdCEEVI6WKNS8yVNOuGW0qLMeCNOcgTeTFd0V865D/XDWF9lBGgc0zRrmBnMi1H7UCOcqWaJmUyaGkZi/LVDoUpVLusFY3KNej8D52Nhm0UilRt28orlpL5JalAl5CTcyOyqhMDniAZsEQagg5M9ZrA2ceWIjplkPKsUxUl/bWPxVHaYg0H+S48bh3V2U4ssYkdKlqrt0dd+F8zPo0kexpJITJxbI6NCNtM8EYmxrDI1m3WTC3PXKPC6Qm40O6cEtj/rK8qcjpMBndtwbdKU3ud9mLrQN0iu6UJMdBLeDyBnCiFPZYsWLulJ0oRb7ymlXqPCn27L22Oo7zpDDUVgxrZ+s8KaTsRsPa8TtPinzjtpv3eVLs+abypNDXyTHWxvX/UhB0pxT/hkbtsW5rPnieFLkZ7YQ16T9Pivxk0J4OnidFckEQYF3OOU+KfyMb/Ecy87KrJPNKc3bFar7zAVKYV1RzVcqsULvyggjzZoNcL2V+PIb1UgPXbjBVZXmTYZyK12Dughto0rJkHatOLA26uz0f/U3eE/sb6rZTVuBz3JRS57nxd8qeXpG835CnxG6G8nbQUR1/3Y9SxnYdTZ3/Fbnot6/CyPqkTehyhB/b3/wyrIzD/ErmAHdxcJSFHGU+l/dXOlD8WCfX/rJBJejavKJyA7nz7h3u4JrjvaLCWiNoG30Mi6zgIM+GNIb1eOAM84aBhlpfNqh5ye2cl4CmTpK3jt9pEXcio1sOJvPQI5b+KPQdFML6KXtsYSuSF42mJp82Ge/3XX4UwotCVrBVpHazoPrdErtSvUnhUSSPX9ml8CwcvnzGIIXhCAN4I0d1TcjggF8OFfhjQXh3TNpT0Xt5EwzBKyyq9p4W3QHDBfzN1TRwEE7ad8bhpOHedbdb39uS4hnk4vBAH7cJ/Fk6buHfOwq0nJO/EzWpUOYF8J2g9Rz7VC4ki4TvH04C2V7uk0t5qGR1cwA8TbKvjS+kSgQtfTgKkOCbuz4zqc0c3zaKBZ7gW5c6FhK2Dc6nfwVu4Vn2rSekOQe1fgczT/vel6RtfzdSBMT2mXMaJmHbJ+nTBHue9ieYsu0TpWBbuzKcYyLkWTcLHEBcauU4x8RujvOsOy5QUA0xDn3fw1cKJAwjPy3bB+tBsKg3Dmv3rebTlNogZG/X/wYmBJuKcBMzs/xUFyQvFdhHsFu9qpvrLTbtuI8eh/ZXd9VfmPh9MdY0an7z4wv5Rf6ooaprb38UK70xx/af7O0YK/O5BFfgyskz6k0oidYDNnYFMYb6p7XWssOtknL85XCFFh3WI24hmo7AZS40Vjq8cTGE2LEnlUHX0gkRrYrB/X01CtA1IVwM73hKYkIennfhPnL9e0eKFFKup4VkuiQiHmjQGM3of8bl7+ePNilSSCFNqwfpkphAb6OjQHp5GQ6iDoa7zagshZzrKSpFVzA8Y/K0aUFNGmOt9p6HdyNZCjlJUkySruB8foe32RV1AAnnR5/9k37yLeRzDIph0BWAxTTRwTLVT/EoRK4+eBqyFHJPXykH6QrEFC9fyNbUBJ6u8ZmWNKKnsWcu9knhfg+v6mpOCjdQ2yPeJqqUIHRFFpqTSlQwK7IU8nYTJd7TFXnQ7yJMS1WaFHI9usPTqihjMG552XEHrYKjS/JQ5hZ5A4AihaRSWjpIl+ShuFpRH0IUKYRCTv3TEnRNHrKTsm4F01qBeHFCyUHFDTA6sooaXZSj7R6SuSJvLbnZcegaMfPSkV2t0UWtNNN+LC4MF4MJMb6GeyfEMyui0zMad0QdZwPRS6+DTSITXf2r4ROSeRt3HnHYY/HX06M/ECpZTj5YDNsuEwSw9sd1ulvVdNyfHXF+d6EC0Ed7wK53hO71qKk4npx3iO1zrKegZKwxR1j2l9A6VBHFKpSeYEQYM84/QK0fI3J3vJ9G3voP7h7+PXnrJsfFi2PRu6YxqVXWPyJ3Ja5M+86x7Yk9J/+/Tv7abokhI39NtET7hnF7bOu2bS44HBYYMvBOljXnwyt65YUMqFBbpxPWMuWpFOo0+VUjqj1sB0HOBCTlwcoP0rgCzZv+LpRHGNaYaVgPkpxM9Acu4icdmob1lYN/gD9QfmzI98X7exQnsL3DEuy33TYyZB3a+wvoHZZsTXeCgl/ByrQxeytsuVPaa39/5R/Tf7YnxDQv6f2VPz//Ae1jzcHA909TAAAAAElFTkSuQmCC",
                fileName="modelica://ETAFactorySimulationLib/BaseClasses/Icons/Data/Core-gear2.png")}));

      end Core;

      class ETAFactorySimLib

        annotation (Icon(graphics={Bitmap(
                extent={{-98,-100},{100,100}},
                imageSource=
                    "iVBORw0KGgoAAAANSUhEUgAAAcYAAAHGCAMAAADZvNsbAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJSUExURf////z9+NfnqsrfjbrVabDPU7bTYsbdhvj78fL3483hlLXSXbvWbOTvxuvz1NTlorrWarDQVcDaeeHtv5fCIpXAHOjxzavOTpXAHaHIOKbKQJ/GMLbUY/X56trpsbPSW6nMR5jDI8TcgJbBHf7+/vH24qDHMarNSNDjm+71273Ycfv898feh5zEKd7ruNPloNXmpvT46dfnqery07HRWNvpsanNSOz017TRX/n78ZbAHcLbfpnBI9bmpurz057GMfH34p7FMq7PUaXJPZzEK6HHN6zMSpW/HbnWa/v997bSY5S/Hfj68NbmqZbBIP7//sfdh+ny0fT56aTJPcDZed3qt7LRWrvXcOvz1u312qjMQ8LbfMvgkZnCKPj78J3FL7vWa+DtvZjCIp3EKtXlpcvgj63NT+/13bjTZZ/HM6fJQMXcg5S/HOv01r7YdZ7EL6vOSrTTXPn78KDGMf///prDJ5nDItrosKrNTZXBH5rBJJnCIpfAHs3hleXwyarOSbPTX+fwypbAHJ/GMrTSXsnfi/z995fAIdnosLfTZKfLQszhk5vDKM/imuDtvq/QUt3rtvX56bXTYafLQZjCI7HRVufxzOPvxd3rt7fVZPf78KrMSLzXcLHQV8Hae/f39+/u7urp6dva2srHx8K/v9DNzeHe3ri1tXZxca2qqvPy8tbU1Hdycubl5drZ2f/+/tHOzp6cnOno6NXT08vIyOXk5OLf3/b29uDd3dzb2/Lx8cLAwK6rq+7t7dfV1cnGxrm2ts/MzMPAwJ+dnXZycgAAAD1pVJ0AAADGdFJOU///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AMYa5+oAAAAJcEhZcwAADsMAAA7DAcdvqGQA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",
                fileName=
                    "modelica://ETAFactorySimulationLib/BaseClasses/Icons/Data/ETAFactorySimLib_Logo.png")}));

      end ETAFactorySimLib;

      partial package IconsPackage "Icon for packages containing icons"
        extends ETAFactorySimulationLib.BaseClasses.Icons.Package;
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Polygon(
                origin={-8.167,-17},
                fillColor={153,204,0},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                    4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                    -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
                smooth=Smooth.Bezier,
                lineColor={0,0,0}), Ellipse(
                origin={-0.5,56.5},
                fillColor={153,204,0},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{-12.5,-12.5},{12.5,12.5}},
                lineColor={0,0,0})}));
      end IconsPackage;

      partial package Package "Icon for standard packages"
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                radius=25,
                fillColor={238,238,238},
                fillPattern=FillPattern.Solid,
                lineColor={215,215,215})}),
                                  Documentation(info="<html>
<p>Standard package icon.</p>
</html>"));
      end Package;

      partial class ProductionSystems "Icon for production system models"
        extends ETAFactorySimulationLib.BaseClasses.Icons.Package;

        annotation (Icon(graphics={Bitmap(
                extent={{-92,-96},{96,92}},
                imageSource=
                    "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",
                fileName=
                    "modelica://ETAFactorySimulationLib/BaseClasses/Icons/Data/Maschinen.png")}));

      end ProductionSystems;

      partial class Pump "Icon for pumps"

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={230,230,230},
                fillPattern=FillPattern.Solid),                                                                                                                                                                                         Text(extent={{
                    -100,-110},{100,-150}},                                                                                                                                                                                                      lineColor=
                    {153,204,0},                                                                                                                                                                                                        fillColor=
                    {122,255,107},
                  fillPattern=FillPattern.Solid,
                textString="%name"),
              Rectangle(
                extent={{-100,20},{100,-20}},
                lineColor={28,108,200},
                fillColor={153,204,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-28,3},{28,-3}},
                lineColor={28,108,200},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                origin={97,-2},
                rotation=90),
              Rectangle(
                extent={{-28,3},{28,-3}},
                lineColor={28,108,200},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                origin={-97,0},
                rotation=90),
              Ellipse(fillColor={238,238,238},
                      fillPattern=FillPattern.Solid,
                      extent={{-80,-80},{80,80}},
                lineColor={153,204,0}),
              Polygon(
                points={{-40,70},{-40,-70},{80,0},{-40,70}},
                lineColor={28,108,200},
                fillColor={153,204,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None)}),                            Documentation(info="<html>
<p>This icon indicates an example. The play button suggests that the example can be executed.</p>
</html>"));
      end Pump;

      partial class Test "Icon for tets"

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
              Ellipse(fillColor={238,238,238},
                      fillPattern=FillPattern.Solid,
                      extent = {{-100,-100},{100,100}},
                lineColor={153,204,0}), Polygon(
                points={{-82,0},{-6,-76},{70,52},{38,52},{-8,-30},{-46,0},{-82,0}},
                lineColor={153,204,0},
                lineThickness=0.5,
                fillColor={153,204,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None)}),                            Documentation(info="<html>
<p>This icon indicates an example. The play button suggests that the example can be executed.</p>
</html>"));
      end Test;

      partial package Utilities_Package "Icon for utility package - Extended from Modelica Standard Library"
          extends ETAFactorySimulationLib.BaseClasses.Icons.Package;
      annotation (Icon(graphics={
        Polygon(
          origin={-0.617,1.8582},
          rotation=45.0,
          fillColor={150,193,20},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}},
              lineColor={0,0,0}),
        Polygon(
          origin={8.102,11.218},
          rotation=-45.0,
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid,
          points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}},
              lineColor={150,193,20})}));
      end Utilities_Package;
    end Icons;
  end BaseClasses;

  package Components "Package containing reccuring basic components of thermohydraulic networks"
    extends ETAFactorySimulationLib.BaseClasses.Icons.Components;

    package Pumps
      extends ETAFactorySimulationLib.BaseClasses.Icons.Components;

      model IdealPump "Ideal pump - Generating a mass flow as a linear function of operating point and nominal mass flow rate"

        //## EXTENSIONS & IMPORTS ##
        extends ETAFactorySimulationLib.BaseClasses.Icons.Pump;
        import Modelica.Constants;
        import Modelica.Units.NonSI;

        //## PARAMETERS ##
        replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choicesAllMatching = true);
        parameter SI.MassFlowRate m_flow_nom=10 "Nominal mass flow rate";
        parameter SI.Power P_el_nom=300 "Nominal electrical power";
        parameter Real u_min=0.3 "Minimal operating point - when u<u_min pump is switched off";
        parameter Real f_el(min=0)=0.7 "Electrical power correction factor - e.g. 0.7 for ASM / 0.9 for PMSM";
        parameter SI.Volume V_int = 0.001 "Internal pump volume";

        parameter Boolean addPowerLossToMedium=true
          "Set to false to avoid any power (= heat and flow work) being added to medium (may give simpler equations)" annotation(Dialog(tab = "Advanced"));
        parameter SI.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nom)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));

      //## COMPONENTS ##
        Modelica.Blocks.Math.Gain gainMassFlow(k=m_flow_nom)                                                      annotation (
            Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=90,
              origin={50,30})));

        Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow prePow(
          final alpha=0) if addPowerLossToMedium
          "Prescribed power (=heat and flow work) flow for dynamic model"
          annotation (Placement(transformation(extent={{10,-10},{-10,10}},
              rotation=90,
              origin={-50,-30})));

        Modelica.Blocks.Math.Gain gainMassFlow1(y(final unit="1"), k=P_el_nom) "Gain to normalized mass flow rate using m_flow_nom" annotation (
            Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=90,
              origin={-50,10})));

        Utilities.PowerN powerN(n=f_el) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={-30,50})));
        Modelica.Blocks.Nonlinear.Limiter m_flow_small_limiter(          uMin=
              m_flow_small, uMax=Modelica.Constants.inf)
                            annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={50,-10})));
        Sources.IdealSource_simple idealSource_simple(redeclare package Medium = Medium, control_m_flow=true) annotation (Placement(transformation(extent={{-20,-90},{0,-70}})));
        Modelica.Fluid.Vessels.ClosedVolume volume(
          redeclare package Medium = Medium,
          use_portsData=false,                     use_HeatTransfer=true,
          V=V_int,                                 nPorts=2)
                                                   annotation (Placement(transformation(extent={{-58,-80},{-38,-60}})));
        Modelica.Fluid.Interfaces.FluidPort_a port_a(redeclare package Medium = Medium)
                                                     annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(redeclare package Medium = Medium)
                                                     annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        Modelica.Fluid.Sensors.MassFlowRate massFlowRate(redeclare package Medium = Medium)
                                                         annotation (Placement(transformation(extent={{20,-90},{40,-70}})));
        Modelica.Blocks.Interfaces.RealInput u
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=270,
              origin={0,120})));
        Modelica.Blocks.Interfaces.RealOutput y_actual(
          final unit="1")
          "Actual normalised pump speed that is used for computations"
          annotation (Placement(transformation(extent={{100,60},{120,80}}),
              iconTransformation(extent={{100,60},{120,80}})));
        Modelica.Blocks.Interfaces.RealOutput P_el(quantity="Power", final unit="W")
          "Electrical power consumed" annotation (Placement(transformation(extent={{100,20},{120,40}}),
                                    iconTransformation(extent={{100,20},{120,40}})));


        Modelica.Blocks.Continuous.FirstOrder firstOrder(T=10, initType=Modelica.Blocks.Types.Init.InitialState)
                                                               annotation (Placement(transformation(extent={{20,40},{40,60}})));
      equation

        connect(P_el, gainMassFlow1.y) annotation (Line(points={{110,30},{0,30},{0,-1},{-50,-1}},
                                  color={0,0,127}));
        connect(gainMassFlow1.u, powerN.y)
          annotation (Line(points={{-50,22},{-50,50},{-41,50}},  color={0,0,127}));
        connect(prePow.Q_flow, gainMassFlow1.y) annotation (Line(points={{-50,-20},{-50,-1}},
                                                             color={0,0,127}));
        connect(gainMassFlow.y, m_flow_small_limiter.u)
          annotation (Line(points={{50,19},{50,2}},            color={0,0,127}));
      connect(y_actual, y_actual)
        annotation (Line(points={{110,70},{110,70}}, color={0,0,127}));
        connect(port_a, volume.ports[1]) annotation (Line(points={{-100,0},{-80,0},{-80,-80},{-49,-80}}, color={0,127,255}));
        connect(volume.ports[2], idealSource_simple.port_a) annotation (Line(points={{-47,-80},{-20,-80}}, color={0,127,255}));
        connect(idealSource_simple.port_b, massFlowRate.port_a) annotation (Line(points={{0,-80},{20,-80}}, color={0,127,255}));
        connect(massFlowRate.port_b, port_b) annotation (Line(points={{40,-80},{80,-80},{80,0},{100,0}}, color={0,127,255}));
        connect(prePow.port, volume.heatPort) annotation (Line(points={{-50,-40},{-50,-50},{-60,-50},{-60,-70},{-58,-70}}, color={191,0,0}));
        connect(gainMassFlow.u, y_actual) annotation (Line(points={{50,42},{50,70},{110,70}}, color={0,0,127}));
        connect(m_flow_small_limiter.y, idealSource_simple.m_flow_in) annotation (Line(points={{50,-21},{50,-40},{-16,-40},{-16,-68}}, color={0,0,127}));
        connect(firstOrder.y, gainMassFlow.u) annotation (Line(points={{41,50},{50,50},{50,42}}, color={0,0,127}));
        connect(firstOrder.u, u) annotation (Line(points={{18,50},{0,50},{0,120}},color={0,0,127}));
        connect(powerN.u, u) annotation (Line(points={{-18,50},{0,50},{0,120}}, color={0,0,127}));
         annotation(Icon(coordinateSystem(preserveAspectRatio=false,
          extent={{-100,-100},{100,100}})),
          Documentation(info="<html>
<p>Ideal pump - Ideal mass flow generating pump based on nominal mass flow rate and operating point. </p>
<h4>Implementation</h4>
<p>This is the base model for fans and pumps as described in <a href=\"ETAFactorySimulationLib.UsersGuide.References\">[PANT19]</a> (pp. 128) excluding the different control modes. It also integrates approaches as used in <span style=\"font-family: Courier New;\">IBPSA</span> library (IBPSA_v300.Fluid.Movers.FlowControlled_m_flow).</p>
<p>It provides an interface between the equations that compute head and power consumption, and the implementation of the energy and pressure balance of the fluid. </p>
<p>The parameter <span style=\"font-family: Courier New;\">addPowerToMedium</span> determines whether any power is added to the fluid. The default is <span style=\"font-family: Courier New;\">addPowerToMedium=true</span>, and hence the outlet enthalpy is higher than the inlet enthalpy if the flow device is operating. The setting <span style=\"font-family: Courier New;\">addPowerToMedium=false</span> is physically incorrect (since the flow work, the flow friction and the fan heat do not increase the enthalpy of the medium), but this setting does in some cases lead to simpler equations and more robust simulation, in particular if the mass flow is equal to zero. </p>
<h4>Dynamics</h4>
<p>The fluid volume is computed using a dynamic balance. </p>
<h4>Validation</h4>
<p>The model has not been validated yet. </p>
</html>"));
      end IdealPump;
    annotation (Documentation(info="<html>
<p>This package contains several pump models.</p>
</html>"));
    end Pumps;

    package Sources
      extends ETAFactorySimulationLib.BaseClasses.Icons.Components;

      model IdealSource_simple "Ideal pressure or mass flow source with two ports"
        //## EXTENSIONS ##
        extends Modelica.Fluid.Interfaces.PartialTwoPortTransport;

        //## PARAMETERS ##
        parameter Boolean control_m_flow
          "if true, then the mass flow rate is equal to the value of m_flow_in"
          annotation(Evaluate = true);
        parameter Boolean control_dp = not control_m_flow
          "if true, then the head is equal to the value of dp_in"
          annotation(Evaluate = true);

        //## VARIABLES ##

        //## PUBLIC COMPONENTS ##

        //## PROTECTED COMPONENTS ##

        Modelica.Blocks.Interfaces.RealInput m_flow_in(unit="kg/s") if control_m_flow
          "Prescribed mass flow rate"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={-50,120}),iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={-60,120})));
        Modelica.Blocks.Interfaces.RealInput dp_in(unit="Pa") if control_dp
          "Prescribed pressure difference port_a.p-port_b.p"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={50,120}),iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={60,120})));

    protected
        Modelica.Blocks.Interfaces.RealInput m_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput dp_internal(unit="Pa")
          "Needed to connect to conditional connector";

      equation
        // Ideal control
        if control_m_flow then
          m_flow = m_flow_internal;
        else
          m_flow_internal = 0;
        end if;
        if control_dp then
          dp = dp_internal;
        else
          dp_internal = 0;
        end if;

        connect(dp_internal, dp_in);
        connect(m_flow_internal, m_flow_in);

        // Energy balance (no storage)
        port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
        port_b.h_outflow = inStream(port_a.h_outflow);

        annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={230,230,230},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,20},{100,-20}},
                lineColor={28,108,200},
                fillColor={153,204,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-100,-20},{100,-24}},
                lineColor={191,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-100,24},{100,20}},
                lineColor={191,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward,
                pattern=LinePattern.None),
              Polygon(
                points={{24,-54},{64,-69},{24,-84},{24,-54}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=showDesignFlowDirection),
              Polygon(
                points={{24,-59},{54,-69},{24,-79},{24,-59}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                visible=allowFlowReversal),
              Line(
                points={{59,-69},{-56,-69}},
                color={0,128,255},
                visible=showDesignFlowDirection),
              Text(
                extent={{-58,14},{54,-12}},
                lineColor={255,255,255},
                textString="dp, m_flow > 0")}),                        Diagram(coordinateSystem(preserveAspectRatio=false)),
          Documentation(info="<html>
<p> Model follows <span style=\"font-family: Courier New;\">IBPSA</span> library (IBPSA_v300.Fluid.Movers.BaseClasses.IdealSource)</p>
</html>"));
      end IdealSource_simple;
    end Sources;
    annotation (Documentation(info="<html>
</html>"));
  end Components;

  package Core "Package containing definite versions of relevant external open source libraries"
      extends ETAFactorySimulationLib.BaseClasses.Icons.Core;

    package IBPSA "Library with models for building energy and control systems"
      extends Modelica.Icons.Package;

      package Fluid "Package with models for fluid flow systems"
        extends Modelica.Icons.Package;

        package FixedResistances "Package with models for fixed flow resistances"
          extends Modelica.Icons.VariantsPackage;

          model PressureDrop
            "Fixed flow resistance with dp and m_flow as parameter"
            extends IBPSA.Fluid.BaseClasses.PartialResistance(final m_flow_turbulent=if computeFlowResistance then deltaM*m_flow_nominal_pos else 0);

            parameter Real deltaM(min=1E-6) = 0.3
              "Fraction of nominal mass flow rate where transition to turbulent occurs"
                 annotation(Evaluate=true,
                            Dialog(group = "Transition to laminar",
                                   enable = not linearized));

            final parameter Real k = if computeFlowResistance then
                  m_flow_nominal_pos / sqrt(dp_nominal_pos) else 0
              "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
        protected
            final parameter Boolean computeFlowResistance=(dp_nominal_pos > Modelica.Constants.eps)
              "Flag to enable/disable computation of flow resistance"
             annotation(Evaluate=true);
            final parameter Real coeff=
              if linearized and computeFlowResistance
              then if from_dp then k^2/m_flow_nominal_pos else m_flow_nominal_pos/k^2
              else 0
              "Precomputed coefficient to avoid division by parameter";
          initial equation
           if computeFlowResistance then
             assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
           end if;

           assert(m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
          equation
            // Pressure drop calculation
            if computeFlowResistance then
              if linearized then
                if from_dp then
                  m_flow = dp*coeff;
                else
                  dp = m_flow*coeff;
                end if;
              else
                if homotopyInitialization then
                  if from_dp then
                    m_flow = homotopy(actual=IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                      dp=dp,
                      k=k,
                      m_flow_turbulent=m_flow_turbulent), simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
                  else
                    dp = homotopy(actual=IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                      m_flow=m_flow,
                      k=k,
                      m_flow_turbulent=m_flow_turbulent), simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
                   end if;  // from_dp
                else // do not use homotopy
                  if from_dp then
                    m_flow = IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                      dp=dp,
                      k=k,
                      m_flow_turbulent=m_flow_turbulent);
                  else
                    dp = IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                      m_flow=m_flow,
                      k=k,
                      m_flow_turbulent=m_flow_turbulent);
                  end if;  // from_dp
                end if; // homotopyInitialization
              end if; // linearized
            else // do not compute flow resistance
              dp = 0;
            end if;  // computeFlowResistance

            annotation (defaultComponentName="res",
          Documentation(info="<html>
<p>
Model of a flow resistance with a fixed flow coefficient.
The mass flow rate is
</p>
<p align=\"center\" style=\"font-style:italic;\">
m&#775; = k
&radic;<span style=\"text-decoration:overline;\">&Delta;p</span>,
</p>
<p>
where
<i>k</i> is a constant and
<i>&Delta;p</i> is the pressure drop.
The constant <i>k</i> is equal to
<code>k=m_flow_nominal/sqrt(dp_nominal)</code>,
where <code>m_flow_nominal</code> and <code>dp_nominal</code>
are parameters.
</p>
<h4>Assumptions</h4>
<p>
In the region
<code>abs(m_flow) &lt; m_flow_turbulent</code>,
the square root is replaced by a differentiable function
with finite slope.
The value of <code>m_flow_turbulent</code> is
computed as
<code>m_flow_turbulent = deltaM * abs(m_flow_nominal)</code>,
where <code>deltaM=0.3</code> and
<code>m_flow_nominal</code> are parameters that can be set by the user.
</p>
<p>
The figure below shows the pressure drop for the parameters
<code>m_flow_nominal=5</code> kg/s,
<code>dp_nominal=10</code> Pa and
<code>deltaM=0.3</code>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/FixedResistances/PressureDrop.png\"/>
</p>
<h4>Important parameters</h4>
<p>
The parameter <code>from_dp</code> is used to determine
whether the mass flow rate is computed as a function of the
pressure drop (if <code>from_dp=true</code>), or vice versa.
This setting can affect the size of the nonlinear system of equations.
</p>
<p>
If the parameter <code>linearized</code> is set to <code>true</code>,
then the pressure drop is computed as a linear function of the
mass flow rate.
</p>
<p>
Setting <code>allowFlowReversal=false</code> can lead to simpler
equations. However, this should only be set to <code>false</code>
if one can guarantee that the flow never reverses its direction.
This can be difficult to guarantee, as pressure imbalance after
the initialization, or due to medium expansion and contraction,
can lead to reverse flow.
</p>
<p>
If the parameter
<code>show_T</code> is set to <code>true</code>,
then the model will compute the
temperature at its ports. Note that this can lead to state events
when the mass flow rate approaches zero,
which can increase computing time.
</p>
<h4>Notes</h4>
<p>
For more detailed models that compute the actual flow friction,
models from the package
<a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
can be used and combined with models from the
<code>IBPSA</code> library.
</p>
<p>
For a model that uses the hydraulic parameter and flow velocity at nominal conditions
as a parameter, use
<a href=\"modelica://IBPSA.Fluid.FixedResistances.HydraulicDiameter\">
IBPSA.Fluid.FixedResistances.HydraulicDiameter</a>.
</p>
<h4>Implementation</h4>
<p>
The pressure drop is computed by calling a function in the package
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels\">
IBPSA.Fluid.BaseClasses.FlowModels</a>,
This package contains regularized implementations of the equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m&#775; = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
and its inverse function.
</p>
<p>
To decouple the energy equation from the mass equations,
the pressure drop is a function of the mass flow rate,
and not the volume flow rate.
This leads to simpler equations.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 21, 2018, by Michael Wetter:<br/>
Decrease value of <code>deltaM(min=...)</code> attribute.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1026\">#1026</a>.
</li>
<li>
February 3, 2018, by Filip Jorissen:<br/>
Revised implementation of pressure drop equation
such that it depends on <code>from_dp</code>
when <code>linearized=true</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/884\">#884</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Simplified model by removing the geometry dependent parameters into the new
model
<a href=\"modelica://IBPSA.Fluid.FixedResistances.HydraulicDiameter\">
IBPSA.Fluid.FixedResistances.HydraulicDiameter</a>.
</li>
<li>
November 23, 2016, by Filip Jorissen:<br/>
Removed <code>dp_nominal</code> and
<code>m_flow_nominal</code> labels from icon.
</li>
<li>
October 14, 2016, by Michael Wetter:<br/>
Updated comment for parameter <code>use_dh</code>.
</li>
<li>
November 26, 2014, by Michael Wetter:<br/>
Added the required <code>annotation(Evaluate=true)</code> so
that the system of nonlinear equations in
<a href=\"modelica://IBPSA.Fluid.FixedResistances.Validation.PressureDropsExplicit\">
IBPSA.Fluid.FixedResistances.Validation.PressureDropsExplicit</a>
remains the same.
</li>
<li>
November 20, 2014, by Michael Wetter:<br/>
Rewrote the warning message using an <code>assert</code> with
<code>AssertionLevel.warning</code>
as this is the proper way to write warnings in Modelica.
</li>
<li>
August 5, 2014, by Michael Wetter:<br/>
Corrected error in documentation of computation of <code>k</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IBPSA.Fluid.BaseClasses.PartialResistance</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IBPSA.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
May 30, 2008 by Michael Wetter:<br/>
Added parameters <code>use_dh</code> and <code>deltaM</code> for easier parameterization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end PressureDrop;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for fixed flow resistances.
By fixed flow resistance, we mean resistances that do not change the
flow coefficient
</p>
<p align=\"center\" style=\"font-style:italic;\">
k = m &frasl;
&radic;<span style=\"text-decoration:overline;\">&Delta;p</span>.
</p>
<p>
For models of valves and air dampers, see
<a href=\"modelica://IBPSA.Fluid.Actuators\">
IBPSA.Fluid.Actuators</a>.
For models of flow resistances as part of the building constructions, see
<a href=\"modelica://IBPSA.Airflow.Multizone\">
IBPSA.Airflow.Multizone</a>.
</p>
<p>
The model
<a href=\"modelica://IBPSA.Fluid.FixedResistances.PressureDrop\">
IBPSA.Fluid.FixedResistances.PressureDrop</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and a nominal pressure drop. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://IBPSA.Fluid.FixedResistances.HydraulicDiameter\">
IBPSA.Fluid.FixedResistances.HydraulicDiameter</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and
a hydraulic diameter. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://IBPSA.Fluid.FixedResistances.LosslessPipe\">
IBPSA.Fluid.FixedResistances.LosslessPipe</a>
is an ideal pipe segment with no pressure drop. It is primarily used
in models in which the above pressure drop model need to be replaced by a model with no pressure drop.
</p>
<p>
The model
<a href=\"modelica://IBPSA.Fluid.FixedResistances.Junction\">
IBPSA.Fluid.FixedResistances.Junction</a>
can be used to model flow splitters or flow merges.
</p>
</html>"));
        end FixedResistances;

        package MixingVolumes "Package with mixing volumes"
          extends Modelica.Icons.VariantsPackage;

          model MixingVolumeMoistAir
            "Mixing volume with heat port for latent heat exchange, to be used if moisture is added or removed"
            extends IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
              dynBal(final use_mWat_flow=true, final use_C_flow=use_C_flow),
              steBal(final use_mWat_flow=true, final use_C_flow=use_C_flow),
              final initialize_p=not Medium.singleState);

            parameter Boolean use_C_flow = false
              "Set to true to enable input connector for trace substance"
              annotation(Evaluate=true, Dialog(tab="Advanced"));

            Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                           final unit = "kg/s")
              "Water flow rate added into the medium"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
            Modelica.Blocks.Interfaces.RealOutput X_w(final unit="kg/kg")
              "Species composition of medium"
              annotation (Placement(transformation(extent={{100,-60},{140,-20}})));

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
              T(start=T_start))
              "Heat port for sensible plus latent heat exchange with the control volume"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

            Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if use_C_flow
              "Trace substance mass flow rate added to the medium"
              annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

        protected
            parameter Real s[Medium.nXi] = {
            if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                      string2="Water",
                                                      caseSensitive=false) then 1 else 0
                                                      for i in 1:Medium.nXi}
              "Vector with zero everywhere except where species is";

            Modelica.Blocks.Sources.RealExpression XLiq(y=s*Xi)
              "Species composition of the medium"
              annotation (Placement(transformation(extent={{72,-52},{94,-28}})));
          equation
            connect(mWat_flow, steBal.mWat_flow) annotation (Line(
                points={{-120,80},{-120,80},{4,80},{4,14},{18,14}},
                color={0,0,127}));
            connect(mWat_flow, dynBal.mWat_flow) annotation (Line(
                points={{-120,80},{-50,80},{52,80},{52,12},{58,12}},
                color={0,0,127}));
            connect(XLiq.y, X_w) annotation (Line(
                points={{95.1,-40},{120,-40}},
                color={0,0,127}));
            connect(heaFloSen.port_a, heatPort)
              annotation (Line(points={{-90,0},{-100,0}}, color={191,0,0}));
            connect(C_flow, steBal.C_flow) annotation (Line(points={{-120,-60},{-80,-60},{
                    12,-60},{12,6},{18,6}}, color={0,0,127}));
            connect(C_flow, dynBal.C_flow) annotation (Line(points={{-120,-60},{-52,-60},{
                    52,-60},{52,6},{58,6}}, color={0,0,127}));
            annotation (defaultComponentName="vol",
          Documentation(info="<html>
<p>
Model for an ideally mixed fluid volume and the ability
to store mass and energy. The volume is fixed,
and latent and sensible heat can be exchanged.
</p>
<p>
This model represents the same physics as
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.MixingVolume\">
IBPSA.Fluid.MixingVolumes.MixingVolume</a>, but in addition, it allows
adding or subtracting water to the control volume.
The mass flow rate of the added or subtracted water is
specified at the port <code>mWat_flow</code>.
Adding <code>mWat_flow</code> itself does not affect the energy balance
in this model. Hence, the enthalpy that is added or removed with the
flow of <code>mWat_flow</code> needs to be added to the heat port
<code>heatPort</code>.
</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<h4>Options</h4>
<p>
The parameter <code>mSenFac</code> can be used to increase the thermal mass of this model
without increasing its volume. This way, species concentrations are still calculated
correctly even though the thermal mass increases. The additional thermal mass is calculated
based on the density and the value of the function <code>HeatCapacityCp</code>
of the medium state <code>state_default</code>. <br/>
This parameter can for instance be useful in a pipe model when the developer wants to
lump the pipe thermal mass to the fluid volume. By default <code>mSenFac = 1</code>, hence
the mass is unchanged. For higher values of <code>mSenFac</code>, the mass will be scaled proportionally.
</p>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector for the trace substance flow rate.
This allows to directly add or subtract trace substances such as
CO2 to the volume.
See
<a href=\"modelica://IBPSA.Fluid.Sensors.Examples.PPM\">IBPSA.Fluid.Sensors.Examples.PPM</a>
for an example.
</p>
</html>",           revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Set <code>initialize_p</code> to <code>final</code> so that it does not
appear as a user-selectable parameter. This is done because
<code>initialize_p</code> has been changed from a <code>constant</code>
to a <code>parameter</code> for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Changed comment of heat port, as this needs to be the total heat flow
rate in order to be able to use this model for modeling steam humidifiers
and adiabatic humidifiers.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>steBal</code>
as this constant is no longer used.
</li>
<li>
January 19, 2016, by Michael Wetter:<br/>
Updated documentation due to the addition of an input for trace substance
in the mixing volume.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">
issue 372</a>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Redesigned implementation of latent and sensible heat flow rates
as port of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
December 18, 2013 by Michael Wetter:<br/>
Changed computation of <code>s</code> to allow this model to also be used
with <code>IBPSA.Media.Water</code>.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Removed dublicate declaration of medium model.
</li>
<li>
September 27, 2013 by Michael Wetter:<br/>
Reformulated assignment of <code>i_w</code> to avoid a warning in OpenModelica.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Changed model to no longer use the obsolete model <code>IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</code>.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>
in the conservation equation model.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the use of the deprecated
<code>cardinality</code> function.
Therefore, all input signals must be connected.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IBPSA.Fluid.Interfaces</code>.
</li>
<li>
February 22, by Michael Wetter:<br/>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
May 29, 2010 by Michael Wetter:<br/>
Rewrote computation of index of water substance.
For the old formulation, Dymola 7.4 failed to differentiate the
model when trying to reduce the index of the DAE.
</li>
<li>
August 7, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end MixingVolumeMoistAir;

          package BaseClasses "Package with base classes for IBPSA.Fluid.MixingVolumes"
            extends Modelica.Icons.BasesPackage;

            model PartialMixingVolume
              "Partial mixing volume with inlet and outlet ports (flow reversal is allowed)"

              extends IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations;
              parameter Boolean initialize_p = not Medium.singleState
                "= true to set up initial equations for pressure"
                annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

              // We set prescribedHeatFlowRate=false so that the
              // volume works without the user having to set this advanced parameter,
              // but to get high robustness, a user can set it to the appropriate value
              // as described in the info section.
              constant Boolean prescribedHeatFlowRate = false
                "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";

              constant Boolean simplify_mWat_flow = true
                "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

              parameter Modelica.Units.SI.MassFlowRate m_flow_nominal(min=0)
                "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));
              // Port definitions
              parameter Integer nPorts=0 "Number of ports"
                annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
              parameter Modelica.Units.SI.MassFlowRate m_flow_small(min=0) = 1E-4*abs(
                m_flow_nominal) "Small mass flow rate for regularization of zero flow"
                annotation (Dialog(tab="Advanced"));
              parameter Boolean allowFlowReversal = true
                "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports."
                annotation(Dialog(tab="Assumptions"), Evaluate=true);
              parameter Modelica.Units.SI.Volume V "Volume";
              Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
                  redeclare each package Medium = Medium) "Fluid inlets and outlets"
                annotation (Placement(transformation(extent={{-40,-10},{40,10}},
                  origin={0,-100})));

              Medium.Temperature T = Medium.temperature_phX(
                p=p,
                h=hOut_internal,
                X=if Medium.reducedX then cat(1, Xi, {1-sum(Xi)}) else Xi)
                "Temperature of the fluid";
              Modelica.Blocks.Interfaces.RealOutput U(unit="J")
                "Internal energy of the component";
              Modelica.Units.SI.Pressure p=if nPorts > 0 then ports[1].p else p_start
                "Pressure of the fluid";
              Modelica.Blocks.Interfaces.RealOutput m(unit="kg") "Mass of the component";
              Modelica.Units.SI.MassFraction Xi[Medium.nXi]=XiOut_internal
                "Species concentration of the fluid";
              Modelica.Blocks.Interfaces.RealOutput mXi[Medium.nXi](each unit="kg")
                "Species mass of the component";
              Medium.ExtraProperty C[Medium.nC](nominal=C_nominal) = COut_internal
                "Trace substance mixture content";
              Modelica.Blocks.Interfaces.RealOutput mC[Medium.nC](each unit="kg")
                "Trace substance mass of the component";

          protected
              IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation steBal(
                final simplify_mWat_flow=simplify_mWat_flow,
                redeclare final package Medium = Medium,
                final m_flow_nominal=m_flow_nominal,
                final allowFlowReversal=allowFlowReversal,
                final m_flow_small=m_flow_small,
                final prescribedHeatFlowRate=prescribedHeatFlowRate,
                hOut(start=Medium.specificEnthalpy_pTX(
                      p=p_start,
                      T=T_start,
                      X=X_start))) if useSteadyStateTwoPort "Model for steady-state balance if nPorts=2" annotation (Placement(transformation(extent={{20,0},{40,20}})));
              IBPSA.Fluid.Interfaces.ConservationEquation dynBal(
                final simplify_mWat_flow=simplify_mWat_flow,
                redeclare final package Medium = Medium,
                final energyDynamics=energyDynamics,
                final massDynamics=massDynamics,
                final p_start=p_start,
                final T_start=T_start,
                final X_start=X_start,
                final C_start=C_start,
                final C_nominal=C_nominal,
                final fluidVolume=V,
                final initialize_p=initialize_p,
                m(start=V*rho_start),
                nPorts=nPorts,
                final mSenFac=mSenFac) if not useSteadyStateTwoPort "Model for dynamic energy balance" annotation (Placement(transformation(extent={{60,0},{80,20}})));

              // Density at start values, used to compute initial values and start guesses
              parameter Modelica.Units.SI.Density rho_start=Medium.density(
                state=state_start) "Density, used to compute start and guess values";
              final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
                  T=Medium.T_default,
                  p=Medium.p_default,
                  X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
              // Density at medium default values, used to compute the size of control volumes
              final parameter Modelica.Units.SI.Density rho_default=Medium.density(
                state=state_default) "Density, used to compute fluid mass";
              final parameter Medium.ThermodynamicState state_start = Medium.setState_pTX(
                  T=T_start,
                  p=p_start,
                  X=X_start[1:Medium.nXi]) "Medium state at start values";
              // See info section for why prescribedHeatFlowRate is used here.
              // The condition below may only be changed if StaticTwoPortConservationEquation
              // contains a correct solution for all foreseeable parameters/inputs.
              // See Buildings, issue 282 for a discussion.
              final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
                  (prescribedHeatFlowRate or (not allowFlowReversal)) and (
                  energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
                  massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
                  substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
                  traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
                "Flag, true if the model has two ports only and uses a steady state balance"
                annotation (Evaluate=true);
              // Outputs that are needed to assign the medium properties
              Modelica.Blocks.Interfaces.RealOutput hOut_internal(unit="J/kg")
                "Internal connector for leaving temperature of the component";
              Modelica.Blocks.Interfaces.RealOutput XiOut_internal[Medium.nXi](each unit="1")
                "Internal connector for leaving species concentration of the component";
              Modelica.Blocks.Interfaces.RealOutput COut_internal[Medium.nC](each unit="1")
                "Internal connector for leaving trace substances of the component";

              Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature preTem
                "Port temperature"
                annotation (Placement(transformation(extent={{-40,-10},{-60,10}})));
              Modelica.Blocks.Sources.RealExpression portT(y=T) "Port temperature"
                annotation (Placement(transformation(extent={{-10,-10},{-30,10}})));
              Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloSen
                "Heat flow sensor"
                annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
            equation
              ///////////////////////////////////////////////////////////////////////////
              // asserts
              if not allowFlowReversal then
                assert(ports[1].m_flow > -m_flow_small,
              "In " + getInstanceName() + ": Model has flow reversal,
  but the parameter allowFlowReversal is set to false.
  m_flow_small    = "             + String(m_flow_small) + "
  ports[1].m_flow = "             + String(ports[1].m_flow) + "
");           end if;
              // Actual definition of port variables.
              //
              // If the model computes the energy and mass balances as steady-state,
              // and if it has only two ports,
              // then we use the same base class as for all other steady state models.
              if useSteadyStateTwoPort then
              connect(steBal.port_a, ports[1]) annotation (Line(
                  points={{20,10},{10,10},{10,-20},{0,-20},{0,-20},{0,-100}},
                  color={0,127,255}));

              connect(steBal.port_b, ports[2]) annotation (Line(
                  points={{40,10},{46,10},{46,-20},{0,-20},{0,-100}},
                  color={0,127,255}));
                U=0;
                mXi=zeros(Medium.nXi);
                m=0;
                mC=zeros(Medium.nC);
                connect(hOut_internal,  steBal.hOut);
                connect(XiOut_internal, steBal.XiOut);
                connect(COut_internal,  steBal.COut);
              else
                  connect(dynBal.ports, ports) annotation (Line(
                  points={{70,0},{70,-80},{62,-80},{2.22045e-15,-80},{2.22045e-15,-90},{2.22045e-15,
                        -100}},
                  color={0,127,255}));
                connect(U,dynBal.UOut);
                connect(mXi,dynBal.mXiOut);
                connect(m,dynBal.mOut);
                connect(mC,dynBal.mCOut);
                connect(hOut_internal,  dynBal.hOut);
                connect(XiOut_internal, dynBal.XiOut);
                connect(COut_internal,  dynBal.COut);
              end if;

              connect(portT.y, preTem.T)
                annotation (Line(points={{-31,0},{-38,0}},   color={0,0,127}));
              connect(heaFloSen.port_b, preTem.port)
                annotation (Line(points={{-70,0},{-65,0},{-60,0}},    color={191,0,0}));
              connect(heaFloSen.Q_flow, steBal.Q_flow) annotation (Line(points={{-80,-10},{
                      -80,-16},{6,-16},{6,18},{18,18}},
                                                 color={0,0,127}));
              connect(heaFloSen.Q_flow, dynBal.Q_flow) annotation (Line(points={{-80,-10},{
                      -80,-10},{-80,-16},{6,-16},{6,24},{50,24},{50,16},{58,16}},
                                                                           color={0,0,127}));
              annotation (
            defaultComponentName="vol",
            Documentation(info="<html>
<p>
This is a partial model of an instantaneously mixed volume.
It is used as the base class for all fluid volumes of the package
<a href=\"modelica://IBPSA.Fluid.MixingVolumes\">
IBPSA.Fluid.MixingVolumes</a>.
</p>


<h4>Typical use and important parameters</h4>
<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
Set the constant <code>simplify_mWat_flow = true</code> to simplify the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
to
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector
for the trace substance flow rate.
</p>
<h4>Implementation</h4>
<p>
If the model is (i) operated in steady-state,
(ii) has two fluid ports connected, and
(iii) <code>prescribedHeatFlowRate=true</code> or <code>allowFlowReversal=false</code>,
then the model uses
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
in order to use
the same energy and mass balance implementation as is used as in
steady-state component models.
In this situation, the functions <code>inStream</code> are used for the two
flow directions rather than the function
<code>actualStream</code>, which is less efficient.
However, the use of <code>inStream</code> has the disadvantage
that <code>hOut</code> has to be computed, in
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>,
using
</p>
<pre>
if allowFlowReversal then
  hOut = IBPSA.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                    y2=port_a.h_outflow,
                                                    x=port_a.m_flow,
                                                    x_small=m_flow_small/1E3);
else
  hOut = port_b.h_outflow;
end if;
</pre>
<p>
Hence, for <code>allowFlowReversal=true</code>, if <code>hOut</code>
were to be used to compute the temperature that
drives heat transfer such as by conduction,
then the heat transfer would depend on upstream and the <i>downstream</i>
temperatures for small mass flow rates.
This can give wrong results. Consider for example a mass flow rate that is positive
but very close to zero. Suppose the upstream temperature is <i>20</i>&deg;C,
the downstream temperature is <i>10</i>&deg;C, and the heat port is
connected through a heat conductor to a boundary condition of <i>20</i>&deg;C.
Then, <code>hOut = (port_b.h_outflow + port_a.h_outflow)/2</code> and hence
the temperature <code>heatPort.T</code>
is <i>15</i>&deg;C. Therefore, heat is added to the component.
As the mass flow rate is by assumption very small, the fluid that leaves the component
will have a very high temperature, violating the 2nd law.
To avoid this situation, if
<code>prescribedHeatFlowRate=false</code>, then the model
<a href=\"modelica://IBPSA.Fluid.Interfaces.ConservationEquation\">
IBPSA.Fluid.Interfaces.ConservationEquation</a>
is used instead of
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://IBPSA.Fluid.MixingVolumes\">
IBPSA.Fluid.MixingVolumes</a>.
</p>
</html>",             revisions="<html>
<ul>
<li>
October 24, 2022, by Michael Wetter:<br/>
Improved conversion from <code>Xi</code> to <code>X</code> so that it also works
with media that have <code>reducedX=true</code>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1650\">#1650</a>.
</li>
<li>
September 18, 2020, by Michael Wetter:<br/>
Set start value for <code>steBal.hOut</code> so that <code>T_start</code>
can be used which is not known in that instance.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1397\">#1397</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
October 30, 2019 by Filip Jorissen:<br/>
Added <code>getInstanceName()</code> to flow
reversal check.
This if or <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1228\">
issue 1228</a>.
</li>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
Removed <code>partial</code> keyword as this model is not partial.<br/>
Moved <code>C_flow</code> and <code>use_C_flow</code> to child classes.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Moved heat port to the extending classes to provide better comment.
Otherwise, the mixing volume without water input would have a comment
that says latent heat can be added at this port.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs U, m, mXi, mC for being able to
check conservation of quantities.
This if or <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Updated model to use the new parameter <code>use_mWat_flow</code>
rather than <code>sensibleOnly</code>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added conditional input <code>C_flow</code> for
handling trace substance insertions.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate=prescribedHeatflowRate</code> for
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
This results in equations that are solved more easily.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Set start value for <code>heatPort.T</code> and changed
type of <code>T</code> to <code>Medium.Temperature</code> rather than
<code>Modelica.Units.SI.Temperature</code>
to avoid an
error because of conflicting start values if
<code>IBPSA.Fluid.Chillers.Carnot_y</code>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> to the actual model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Improved documentation and changed the test
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 prescribedHeatFlowRate and ...
</pre>
to
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 (prescribedHeatFlowRate or (not allowFlowReversal)) and ...
</pre>
The reason is that if there is no flow reversal, then
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
computes <code>hOut =  port_b.h_outflow;</code>, and hence
it is correct to use <code>hOut</code> to compute
temperature-driven heat flow, such as by conduction or convection.
See also the model documentation.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">
#412</a>.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
October 29, 2014, by Michael Wetter:<br/>
Made assignment of <code>mFactor</code> final, and changed computation of
density to use default medium states as are also used to compute the
specific heat capacity.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Removed <code>Q_flow</code> and added <code>QSen_flow</code>.
This was done to clarify what is sensible and total heat flow rate
as part of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to instance <code>steBal</code> as it has no longer this parameter.
</li>
<li>
September 13, 2013 by Michael Wetter:<br/>
Renamed <code>rho_nominal</code> to <code>rho_start</code>
because this quantity is computed using start values and not
nominal values.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the check of multiple connections to the same element
of a fluid port, as this check required the use of the deprecated
<code>cardinality</code> function.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IBPSA.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"modelica://IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations\">
IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
This implementation also simplifies the implementation of
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort\">
IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</a>,
which now uses the same equations as this model.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
IBPSA.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                        100}}), graphics={
                   Text(
                      extent={{-60,-26},{56,-58}},
                      textColor={255,255,255},
                      textString="V=%V"),
                    Text(
                      extent={{-152,100},{148,140}},
                      textString="%name",
                      textColor={0,0,255}),
                   Ellipse(
                      extent={{-100,98},{100,-102}},
                      lineColor={0,0,0},
                      fillPattern=FillPattern.Sphere,
                      fillColor=DynamicSelect({170,213,255}, min(1, max(0, (1-(T-273.15)/50)))*{28,108,200}+min(1, max(0, (T-273.15)/50))*{255,0,0})),
                    Text(
                      extent={{62,28},{-58,-22}},
                      textColor={255,255,255},
                      textString=DynamicSelect("", String(T-273.15, format=".1f")))}));
            end PartialMixingVolume;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Fluid.MixingVolumes\">IBPSA.Fluid.MixingVolumes</a>.
</p>
</html>"));
          end BaseClasses;
        annotation (Documentation(info="<html>
<p>
This package contains models for completely mixed volumes.
</p>
<p>
For most situations, the model
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.MixingVolume\">
IBPSA.Fluid.MixingVolumes.MixingVolume</a> should be used.
The other models are only of interest if water should be added to
or subtracted from the fluid volume, such as in a
coil with water vapor condensation.
</p>
</html>"));
        end MixingVolumes;

        package Sensors "Package with sensor models"
          extends Modelica.Icons.SensorsPackage;

          model Temperature "Ideal one port temperature sensor"
            extends IBPSA.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor;

            Modelica.Blocks.Interfaces.RealOutput T(final quantity="ThermodynamicTemperature",
                                                    final unit = "K",
                                                    min=0,
                                                    displayUnit = "degC")
              "Temperature in port medium"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));

          equation
            T = Medium.temperature(state=Medium.setState_phX(
                  p=port.p, h=inStream(port.h_outflow), X=inStream(port.Xi_outflow)));

          annotation (
            defaultComponentName="senTem",
            Documentation(info="<html>
<p>
This model outputs the temperature of the fluid connected to its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
<p>
To measure temperature in a duct or pipe, use
<a href=\"modelica://IBPSA.Fluid.Sensors.TemperatureTwoPort\">IBPSA.Fluid.Sensors.TemperatureTwoPort</a>
rather than this sensor.
Read the
<a href=\"modelica://IBPSA.Fluid.Sensors.UsersGuide\">
IBPSA.Fluid.Sensors.UsersGuide</a>
prior to using this model to see about potential numerical problems if this sensor is used incorrectly
in a system model.
</p>
</html>", revisions="<html>
<ul>
<li>
September 21, 2020, by Michael Wetter:<br/>
Introduced parameter <code>warnAboutOnePortConnection</code> and updated documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1399\">#1399</a>.
</li>
<li>
February 21, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,100}}),
                                  graphics={
                  Line(points={{0,-70},{0,-100}}, color={0,0,127}),
                  Ellipse(
                    extent={{-20,-98},{20,-60}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-12,40},{12,-68}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{
                        12,80},{12,40},{-12,40}},
                    lineColor={0,0,0},
                    lineThickness=0.5),
                  Line(
                    points={{-12,40},{-12,-64}},
                    thickness=0.5),
                  Line(
                    points={{12,40},{12,-64}},
                    thickness=0.5),
                  Line(points={{-40,-20},{-12,-20}}),
                  Line(points={{-40,20},{-12,20}}),
                  Line(points={{-40,60},{-12,60}}),
                  Line(points={{12,0},{60,0}}, color={0,0,127})}),
              Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}}), graphics={
                  Ellipse(
                    extent={{-20,-88},{20,-50}},
                    lineColor={0,0,0},
                    lineThickness=0.5,
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-12,50},{12,-58}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-12,50},{-12,90},{-10,96},{-6,98},{0,100},{6,98},{10,96},{12,
                        90},{12,50},{-12,50}},
                    lineColor={0,0,0},
                    lineThickness=0.5),
                  Line(
                    points={{-12,50},{-12,-54}},
                    thickness=0.5),
                  Line(
                    points={{12,50},{12,-54}},
                    thickness=0.5),
                  Line(points={{-40,-10},{-12,-10}}),
                  Line(points={{-40,30},{-12,30}}),
                  Line(points={{-40,70},{-12,70}}),
                  Text(
                    extent={{126,-30},{6,-60}},
                    textColor={0,0,0},
                    textString="T"),
                  Text(
                    extent={{-150,110},{150,150}},
                    textString="%name",
                    textColor={0,0,255}),
                  Line(points={{12,0},{60,0}}, color={0,0,127}),
                  Text(
                    extent={{180,90},{60,40}},
                    textColor={0,0,0},
                    textString=DynamicSelect("", String(T-273.15, format=".1f")))}));
          end Temperature;

          package BaseClasses "Package with base classes for IBPSA.Fluid.Sensors"
            extends Modelica.Icons.BasesPackage;

            partial model PartialAbsoluteSensor
              "Partial component to model a sensor that measures a potential variable"

              replaceable package Medium=Modelica.Media.Interfaces.PartialMedium
                "Medium in the sensor"
                annotation (choices(
                    choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
                    choice(redeclare package Medium = IBPSA.Media.Water "Water"),
                    choice(redeclare package Medium =
                        IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                          property_T=293.15,
                          X_a=0.40)
                          "Propylene glycol water, 40% mass fraction")));

              parameter Boolean warnAboutOnePortConnection = true
               "Set to false to suppress warning about potential numerical issues, see IBPSA.Fluid.Sensors.UsersGuide for more information"
               annotation(HideResult=true);
              Modelica.Fluid.Interfaces.FluidPort_a port(redeclare package Medium=Medium, m_flow(min=0))
                annotation (Placement(transformation(
                    origin={0,-100},
                    extent={{-10,-10},{10,10}},
                    rotation=90)));

          protected
              parameter String instanceName = getInstanceName() "Name of the instance";
            initial equation
              assert(not warnAboutOnePortConnection,
              "Sensor " + instanceName + " can lead to numerical problems if connected to a scalar fluid port.
  Only connect it to a vectorized fluid port, such as used in 'IBPSA.Fluid.MixingVolumes`.
  See IBPSA.Fluid.Sensors.UsersGuide for more information.
  To disable this warning, set 'warnAboutOnePortConnection = false' in "             + instanceName + ".",
              level=AssertionLevel.warning);
            equation
              port.m_flow = 0;
              port.h_outflow = 0;
              port.Xi_outflow = zeros(Medium.nXi);
              port.C_outflow = zeros(Medium.nC);
              annotation (Documentation(info="<html>
<p>
Partial component to model an absolute sensor.
The component can be used for pressure sensor models.
Use for other properties such as temperature or density is discouraged, because the enthalpy at the connector can have different meanings, depending on the connection topology. For these properties, use
<a href=\"modelica://IBPSA.Fluid.Sensors.BaseClasses.PartialFlowSensor\">
IBPSA.Fluid.Sensors.BaseClasses.PartialFlowSensor</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
September 20, 2020, by Michael Wetter:<br/>
Introduced parameter <code>warnAboutOnePortConnection</code> and added assertion with level set to warning.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1399\"> #1399</a>.
</li>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
September 7, 2018, by Michael Wetter:<br/>
Changed
<code>port(redeclare package Medium=Medium, m_flow(min=0, max=0))</code>
to
<code>port(redeclare package Medium=Medium, m_flow(min=0))</code>
to avoid in Dymola 2019FD01 beta1 the message
\"port.m_flow has the range [0,0] - which is suspicious since the max-value should be above the min-value\"
which causes an error in pedantic mode.
Note that the MSL also uses only a <code>min</code> value.
</li>
<li>
March 22, 2017, by Filip Jorissen:<br/>
Set <code>m_flow(max=0)</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/687\">#687</a>.
</li>
<li>
February 12, 2011, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"),  Icon(
              graphics={
                Bitmap(
                  visible = warnAboutOnePortConnection,
                  extent={{-96,-82},{-64,-50}},
                  fileName="modelica://ETAFactorySimulationLib/Resources/Images/Fluid/Sensors/warningIcon.png")}));
            end PartialAbsoluteSensor;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Fluid.Sensors\">IBPSA.Fluid.Sensors</a>.
</p>
</html>"));
          end BaseClasses;
        annotation (preferredView="info",
        Documentation(info="<html>
<p>
Package <code>Sensors</code> consists of idealized sensor components that
provide variables of a medium as
output signals. These signals can be, e.g., further processed
with components of the
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>
library.
</p>
</html>",     revisions="<html>
<ul>
<li><i>22 Dec 2008</i>
    by R&uuml;diger Franke
    <ul>
    <li>flow sensors based on Modelica.Fluid.Interfaces.PartialTwoPort</li>
    <li>adapted documentation to stream connectors, i.e. less need for two port sensors</li>
    </ul>
</li>
<li><i>4 Dec 2008</i>
    by Michael Wetter<br/>
       included sensors for trace substance</li>
<li><i>31 Oct 2007</i>
    by Carsten Heinrich<br/>
       updated sensor models, included one and two port sensors for thermodynamic state variables</li>
</ul>
</html>"));
        end Sensors;

        package Interfaces "Package with interfaces for fluid models"
          extends Modelica.Icons.InterfacesPackage;

          model ConservationEquation "Lumped volume with mass and energy balance"

            extends IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations;

            // Constants
            parameter Boolean initialize_p = not Medium.singleState
              "= true to set up initial equations for pressure"
              annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

            constant Boolean simplify_mWat_flow = true
              "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";

            // Port definitions
            parameter Integer nPorts=0 "Number of ports"
              annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));

            parameter Boolean use_mWat_flow = false
              "Set to true to enable input connector for moisture mass flow rate"
              annotation(Evaluate=true, Dialog(tab="Advanced"));
            parameter Boolean use_C_flow = false
              "Set to true to enable input connector for trace substance"
              annotation(Evaluate=true, Dialog(tab="Advanced"));

            Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
              "Sensible plus latent heat flow rate transferred into the medium"
              annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
            Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                           unit="kg/s")
              if use_mWat_flow "Moisture mass flow rate added to the medium"
              annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
            Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow
              if use_C_flow "Trace substance mass flow rate added to the medium"
              annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

            // Outputs that are needed in models that use this model
            Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                       start=hStart)
              "Leaving specific enthalpy of the component"
               annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-50,110})));
            Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                    each min=0,
                                                                    each max=1)
              "Leaving species concentration of the component"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={0,110})));
            Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
              "Leaving trace substances of the component"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={50,110})));
            Modelica.Blocks.Interfaces.RealOutput UOut(unit="J")
              "Internal energy of the component" annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  origin={110,20})));
            Modelica.Blocks.Interfaces.RealOutput mXiOut[Medium.nXi](each min=0, each unit="kg")
              "Species mass of the component"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  origin={110,-20})));
            Modelica.Blocks.Interfaces.RealOutput mOut(min=0, unit="kg")
              "Mass of the component" annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  origin={110,60})));
            Modelica.Blocks.Interfaces.RealOutput mCOut[Medium.nC](each min=0, each unit="kg")
              "Trace substance mass of the component"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  origin={110,-60})));

            Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
                redeclare each final package Medium = Medium) "Fluid inlets and outlets"
              annotation (Placement(transformation(extent={{-40,-10},{40,10}},
                origin={0,-100})));

            // Set nominal attributes where literal values can be used.
            Medium.BaseProperties medium(
              p(start=p_start),
              h(start=hStart),
              T(start=T_start),
              Xi(
                each stateSelect=if medium.preferredMediumStates then StateSelect.prefer else StateSelect.default,
                start=X_start[1:Medium.nXi]),
              X(start=X_start),
              d(start=rho_start)) "Medium properties";

            Modelica.Units.SI.Energy U(
              start=fluidVolume*rho_start*
                  Medium.specificInternalEnergy(Medium.setState_pTX(
                  T=T_start,
                  p=p_start,
                  X=X_start[1:Medium.nXi])) + (T_start - Medium.reference_T)*CSen,
                nominal=1E5) "Internal energy of fluid";

            Modelica.Units.SI.Mass m(start=fluidVolume*rho_start, stateSelect=if
                  massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
                  StateSelect.default else StateSelect.prefer) "Mass of fluid";

            Modelica.Units.SI.Mass[Medium.nXi] mXi(
              each stateSelect=StateSelect.never,
              start=fluidVolume*rho_start*X_start[1:Medium.nXi])
              "Masses of independent components in the fluid";
            Modelica.Units.SI.Mass[Medium.nC] mC(start=fluidVolume*rho_start*C_start)
              "Masses of trace substances in the fluid";
            // C need to be added here because unlike for Xi, which has medium.Xi,
            // there is no variable medium.C
            Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
              "Trace substance mixture content";

            Modelica.Units.SI.MassFlowRate mb_flow "Mass flows across boundaries";
            Modelica.Units.SI.MassFlowRate[Medium.nXi] mbXi_flow
              "Substance mass flows across boundaries";
            Medium.ExtraPropertyFlowRate[Medium.nC] mbC_flow
              "Trace substance mass flows across boundaries";
            Modelica.Units.SI.EnthalpyFlowRate Hb_flow
              "Enthalpy flow across boundaries or energy source/sink";

            // Parameters that need to be defined by an extending class
            parameter Modelica.Units.SI.Volume fluidVolume "Volume";
            final parameter Modelica.Units.SI.HeatCapacity CSen=(mSenFac - 1)*rho_default
                *cp_default*fluidVolume
              "Aditional heat capacity for implementing mFactor";
        protected
            Medium.EnthalpyFlowRate ports_H_flow[nPorts];
            Modelica.Units.SI.MassFlowRate ports_mXi_flow[nPorts,Medium.nXi];
            Medium.ExtraPropertyFlowRate ports_mC_flow[nPorts,Medium.nC];
            parameter Modelica.Units.SI.SpecificHeatCapacity cp_default=
                Medium.specificHeatCapacityCp(state=state_default)
              "Heat capacity, to compute additional dry mass";
            parameter Modelica.Units.SI.Density rho_start=Medium.density(
                Medium.setState_pTX(
                T=T_start,
                p=p_start,
                X=X_start[1:Medium.nXi])) "Density, used to compute fluid mass";

            // Parameter for avoiding extra overhead calculations when CSen==0
            final parameter Boolean computeCSen = abs(mSenFac-1) > Modelica.Constants.eps
              annotation(Evaluate=true);
            final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
                T=Medium.T_default,
                p=Medium.p_default,
                X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
            // Density at medium default values, used to compute the size of control volumes
            final parameter Modelica.Units.SI.Density rho_default=Medium.density(state=
                state_default) "Density, used to compute fluid mass";
            // Parameter that is used to construct the vector mXi_flow
            final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(
                                                      string1=Medium.substanceNames[i],
                                                      string2="Water",
                                                      caseSensitive=false)
                                                      then 1 else 0 for i in 1:Medium.nXi}
              "Vector with zero everywhere except where species is";
            parameter Modelica.Units.SI.SpecificEnthalpy hStart=
                Medium.specificEnthalpy_pTX(
                p_start,
                T_start,
                X_start) "Start value for specific enthalpy";

            // Set _simplify_mWat_flow == false for Glycol47; otherwise Dymola 2018FD01
            // cannot differentiate the equations.
            constant Boolean _simplify_mWat_flow = simplify_mWat_flow and Medium.nX > 1
             "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";

            // Conditional connectors
            Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
              "Needed to connect to conditional connector";
            Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
              "Needed to connect to conditional connector";

          initial equation
            // Assert that the substance with name 'water' has been found.
            if use_mWat_flow then
              assert(Medium.nXi == 0 or abs(sum(s) - 1) < 1e-5, "In " + getInstanceName()
                 + ":
         If Medium.nXi > 1, then substance 'water' must be present for one component of '"
                 + Medium.mediumName + "'.
         Check medium model.");
            end if;

            // Make sure that if energyDynamics is SteadyState, then
            // massDynamics is also SteadyState.
            // Otherwise, the system of ordinary differential equations may be inconsistent.
            if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
              assert(massDynamics == energyDynamics, "In " + getInstanceName() + ":
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
            end if;

            // initialization of balances
            if energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
                medium.T = T_start;
            else
              if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
                  der(medium.T) = 0;
              end if;
            end if;

            if massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
              if initialize_p then
                medium.p = p_start;
              end if;
            else
              if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
                if initialize_p then
                  der(medium.p) = 0;
                end if;
              end if;
            end if;

            if substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
              medium.Xi = X_start[1:Medium.nXi];
            else
              if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
                der(medium.Xi) = zeros(Medium.nXi);
              end if;
            end if;

            if traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
              C = C_start[1:Medium.nC];
            else
              if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
                der(C) = zeros(Medium.nC);
              end if;
            end if;

          equation
            // Conditional connectors
            connect(mWat_flow, mWat_flow_internal);
            if not use_mWat_flow then
              mWat_flow_internal = 0;
            end if;

            connect(C_flow, C_flow_internal);
            if not use_C_flow then
              C_flow_internal = zeros(Medium.nC);
            end if;

            // Total quantities
            if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
              m = fluidVolume*rho_start;
            else
              if _simplify_mWat_flow then
                // If moisture is neglected in mass balance, assume for computation
                // of the mass of air that the air is at Medium.X_default.
                m = fluidVolume*Medium.density(Medium.setState_phX(
                  p = medium.p,
                  h = hOut,
                  X = Medium.X_default));
              else
                // Use actual density
                m = fluidVolume*medium.d;
              end if;
            end if;
            mXi = m*medium.Xi;
            if computeCSen then
              U = m*medium.u + CSen*(medium.T-Medium.reference_T);
            else
              U = m*medium.u;
            end if;
            mC = m*C;

            hOut = medium.h;
            XiOut = medium.Xi;
            COut = C;

            for i in 1:nPorts loop
              //The semiLinear function should be used for the equations below
              //for allowing min/max simplifications.
              //See https://github.com/ibpsa/modelica-ibpsa/issues/216 for a discussion and motivation
              ports_H_flow[i]     = semiLinear(ports[i].m_flow, inStream(ports[i].h_outflow), ports[i].h_outflow)
                "Enthalpy flow";
              for j in 1:Medium.nXi loop
                ports_mXi_flow[i,j] = semiLinear(ports[i].m_flow, inStream(ports[i].Xi_outflow[j]), ports[i].Xi_outflow[j])
                  "Component mass flow";
              end for;
              for j in 1:Medium.nC loop
                ports_mC_flow[i,j]  = semiLinear(ports[i].m_flow, inStream(ports[i].C_outflow[j]),  ports[i].C_outflow[j])
                  "Trace substance mass flow";
              end for;
            end for;

            for i in 1:Medium.nXi loop
              mbXi_flow[i] = sum(ports_mXi_flow[:,i]);
            end for;

            for i in 1:Medium.nC loop
              mbC_flow[i]  = sum(ports_mC_flow[:,i]);
            end for;

            mb_flow = sum(ports.m_flow);
            Hb_flow = sum(ports_H_flow);

            // Energy and mass balances
            if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
              0 = Hb_flow + Q_flow;
            else
              der(U) = Hb_flow + Q_flow;
            end if;

            if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
              0 = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
            else
              der(m) = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
            end if;

            if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
              zeros(Medium.nXi) = mbXi_flow + mWat_flow_internal * s;
            else
              der(medium.Xi) = (mbXi_flow + mWat_flow_internal * s)/m;
            end if;

            if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
              zeros(Medium.nC)  = mbC_flow + C_flow_internal;
            else
              der(mC)  = mbC_flow + C_flow_internal;
            end if;

            // Properties of outgoing flows
            for i in 1:nPorts loop
                ports[i].p          = medium.p;
                ports[i].h_outflow  = medium.h;
                ports[i].Xi_outflow = medium.Xi;
                ports[i].C_outflow  = C;
            end for;
            UOut=U;
            mXiOut=mXi;
            mOut=m;
            mCOut=mC;
            annotation (
              Documentation(info="<html>
<p>
Basic model for an ideally mixed fluid volume with the ability to store mass and energy.
It implements a dynamic or a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code> then adding
moisture does not increase the mass of the volume or the leaving mass flow rate.
It does however change the mass fraction <code>medium.Xi</code>.
This allows to decouple the moisture balance from the pressure drop equations.
If <code>simplify_mWat_flow = false</code>, then
the outlet mass flow rate is
<i>m<sub>out</sub> = m<sub>in</sub>  (1 + &Delta; X<sub>w</sub>)</i>,
where
<i>&Delta; X<sub>w</sub></i> is the change in water vapor mass
fraction across the component. In this case,
this component couples
the energy calculation to the
pressure drop versus mass flow rate calculations.
However, in typical building HVAC systems,
<i>&Delta; X<sub>w</sub></i> &lt; <i>0.005</i> kg/kg.
Hence, by tolerating a relative error of <i>0.005</i> in the mass balance,
one can decouple these equations.
Decoupling these equations avoids having
to compute the energy balance of the humidifier
and its upstream components when solving for the
pressure drop of downstream components.
Therefore, the default value is <code>simplify_mWat_flow = true</code>.
</p>
<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
The model
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling\">
IBPSA.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling</a>
shows that the relative error on the temperature difference between these
two options of <code>simplify_mWat_flow</code> is less than
<i>0.1%</i>.
</p>

<h4>Implementation</h4>
<p>
When extending or instantiating this model, the input
<code>fluidVolume</code>, which is the actual volume occupied by the fluid,
needs to be assigned.
For most components, this can be set to a parameter.
</p>
Input connectors of the model are
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can be used as a dynamic model or as a steady-state model.
However, for a steady-state model with exactly two fluid ports connected,
the model
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
provides a more efficient implementation.
</p>
<p>
For a model that instantiates this model, see
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.MixingVolume\">
IBPSA.Fluid.MixingVolumes.MixingVolume</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
October 24, 2022, by Michael Wetter:<br/>
Conditionally removed assertion that checks for water content as this is
only required if water is added to the medium.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1650\">#1650</a>.
</li>
<li>
September 9, 2022, by Michael Wetter:<br/>
Changed state variable from <code>mXi</code> to <code>medium.Xi</code>
as this allows setting a good nominal attribute without having to use the fluid volume,
which is non-literal value that leads to a warning in Dymola.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1634\">1634</a>.
</li>
<li>
April 26, 2019, by Filip Jorissen:<br/>
Returning <code>getInstanceName()</code> in asserts.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1133\">1133</a>.
</li>
<li>
April 16, 2019, by Michael Wetter:<br/>
Changed computation of <code>computeCSen</code> to avoid the volume to become
a structural parameter.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1122\">IBPSA, issue 1122</a>.
</li>
<li>
April 16, 2018, by Michael Wetter:<br/>
Reformulated mass calculation so that Dymola can differentiate the equations.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/910\">IBPSA, issue 910</a>.
</li>
<li>
November 3, 2017, by Michael Wetter:<br/>
Set <code>start</code> attributes.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/727\">727</a>.
</li>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
January 27, 2017, by Michael Wetter:<br/>
Added <code>stateSelect</code> for mass <code>m</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/642\">
Buildings, #642</a>.
</li>
<li>
December 22, 2016, by Michael Wetter:<br/>
Set nominal value for <code>U</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/637\">637</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs UOut, mOut, mXiOut, mCOut for being able to
check conservation of quantities.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Added <code>C_flow</code> to the steady-state trace substance balance,
and removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
</li>
<li>
September 3, 2015, by Filip Jorissen and Michael Wetter:<br/>
Revised implementation for allowing moisture mass flow rate
to be approximated using parameter <code>simplify_mWat_flow</code>.
This may lead to smaller algebraic loops.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
June 5, 2015 by Michael Wetter:<br/>
Removed <code>preferredMediumStates= false</code> in
the instance <code>medium</code> as the default
is already <code>false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015 by Filip Jorissen:<br/>
Removed <pre>
Xi(start=X_start[1:Medium.nXi],
       each stateSelect=if (not (substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState))
       then StateSelect.prefer else StateSelect.default),
</pre>
and set
<code>preferredMediumStates = false</code>
because the previous declaration led to more equations and
translation problems in large models.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> of <code>PartialMixingVolume</code>
to this model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
This revison also renames the protected variable
<code>rho_nominal</code> to <code>rho_start</code>
as it depends on the start values and not the nominal values.
</li>
<li>
May 22, 2015 by Michael Wetter:<br/>
Removed <pre>
p(stateSelect=if not (massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
then StateSelect.prefer else StateSelect.default)
</pre>
because the previous declaration led to the translation error
<pre>
The model requires derivatives of some inputs as listed below:
1 inlet.m_flow
1 inlet.p
</pre>
when translating
<code>Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.HeaterCooler_u</code>
with a dynamic energy balance.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
April 13, 2015, by Filip Jorissen:<br/>
Now using <code>semiLinear()</code> function for calculation of
<code>ports_H_flow</code>. This enables Dymola to simplify based on
the <code>min</code> and <code>max</code> attribute of the mass flow rate.
</li>
<li>
February 16, 2015, by Filip Jorissen:<br/>
Fixed SteadyState massDynamics implementation for compressible media.
Mass <code>m</code> is now constant.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Set start attributes in <code>medium</code> to avoid in OpenModelica the warning
alias set with several free start values.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>
September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.<br/>
Corrected the syntax error
<code>Medium.ExtraProperty C[Medium.nC](each nominal=C_nominal)</code>
to
<code>Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)</code>
because <code>C_nominal</code> is a vector.
This syntax error caused a compilation error in OpenModelica.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
July 31, 2011 by Michael Wetter:<br/>
Added test to stop model translation if the setting for
<code>energyBalance</code> and <code>massBalance</code>
can lead to inconsistent equations.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Removed the option to use <code>h_start</code>, as this
is not needed for building simulation.
Also removed the reference to <code>Modelica.Fluid.System</code>.
Moved parameters and medium to
<a href=\"modelica://IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations\">
IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start value for medium density.
</li>
<li>
March 29, 2011 by Michael Wetter:<br/>
Changed default value for <code>substanceDynamics</code> and
<code>traceDynamics</code> from <code>energyDynamics</code>
to <code>massDynamics</code>.
</li>
<li>
September 28, 2010 by Michael Wetter:<br/>
Changed array index for nominal value of <code>Xi</code>.
</li>
<li>
September 13, 2010 by Michael Wetter:<br/>
Set nominal attributes for medium based on default medium values.
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added parameter <code>C_nominal</code> which is used as the nominal attribute for <code>C</code>.
Without this value, the ODE solver gives wrong results for concentrations around 1E-7.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li><i>February 6, 2010</i> by Michael Wetter:<br/>
Added to <code>Medium.BaseProperties</code> the initialization
<code>X(start=X_start[1:Medium.nX])</code>. Previously, the initialization
was only done for <code>Xi</code> but not for <code>X</code>, which caused the
medium to be initialized to <code>reference_X</code>, ignoring the value of <code>X_start</code>.
</li>
<li><i>October 12, 2009</i> by Michael Wetter:<br/>
Implemented first version in <code>Buildings</code> library, based on model from
<code>Modelica.Fluid 1.0</code>.
</li>
</ul>
</html>"),    Icon(graphics={            Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={135,135,135},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-89,17},{-54,34}},
                    textColor={0,0,127},
                    textString="mWat_flow"),
                  Text(
                    extent={{-89,52},{-54,69}},
                    textColor={0,0,127},
                    textString="Q_flow"),
                  Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
                  Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
                  Polygon(
                    points={{-42,67},{-50,45},{-34,45},{-42,67}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{87,-73},{65,-65},{65,-81},{87,-73}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-42,-28},{-6,-28},{18,4},{40,12},{66,14}},
                    color={255,255,255},
                    smooth=Smooth.Bezier),
                  Text(
                    extent={{-155,-120},{145,-160}},
                    textColor={0,0,255},
                    textString="%name")}));
          end ConservationEquation;

          block LumpedVolumeDeclarations "Declarations for lumped volumes"
            replaceable package Medium =
              Modelica.Media.Interfaces.PartialMedium "Medium in the component"
                annotation (choices(
                  choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
                  choice(redeclare package Medium = IBPSA.Media.Water "Water"),
                  choice(redeclare package Medium =
                      IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                        property_T=293.15,
                        X_a=0.40)
                        "Propylene glycol water, 40% mass fraction")));

            // Assumptions
            parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
              "Type of energy balance: dynamic (3 initialization options) or steady state"
              annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Conservation equations"));
            parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
              "Type of mass balance: dynamic (3 initialization options) or steady state, must be steady state if energyDynamics is steady state"
              annotation(Evaluate=true, Dialog(tab = "Advanced", group="Dynamics"));
            final parameter Modelica.Fluid.Types.Dynamics substanceDynamics=energyDynamics
              "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state"
              annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Conservation equations"));
            final parameter Modelica.Fluid.Types.Dynamics traceDynamics=energyDynamics
              "Type of trace substance balance: dynamic (3 initialization options) or steady state"
              annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Conservation equations"));

            // Initialization
            parameter Medium.AbsolutePressure p_start = Medium.p_default
              "Start value of pressure"
              annotation(Dialog(tab = "Initialization"));
            parameter Medium.Temperature T_start=Medium.T_default
              "Start value of temperature"
              annotation(Dialog(tab = "Initialization"));
            parameter Medium.MassFraction X_start[Medium.nX](
                 quantity=Medium.substanceNames) = Medium.X_default
              "Start value of mass fractions m_i/m"
              annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
            parameter Medium.ExtraProperty C_start[Medium.nC](
                 quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
              "Start value of trace substances"
              annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
            parameter Medium.ExtraProperty C_nominal[Medium.nC](
                 quantity=Medium.extraPropertiesNames) = fill(1E-2, Medium.nC)
              "Nominal value of trace substances. (Set to typical order of magnitude.)"
             annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
            parameter Real mSenFac(min=1)=1
              "Factor for scaling the sensible thermal mass of the volume"
              annotation(Dialog(tab="Dynamics"));

            // The parameter below is evaluated by OCT during compilation, and
            // if false, the assert statement won't be optimized away during
            // code generation.
        protected
            final parameter Boolean wrongEnergyMassBalanceConfiguration=
              not (energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState or
                   massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
              "True if configuration of energy and mass balance is wrong."
              annotation(Evaluate=true);
          initial equation
            if wrongEnergyMassBalanceConfiguration then
            assert(not wrongEnergyMassBalanceConfiguration,
                   "In " + getInstanceName() +
                   ": energyDynamics is selected as steady state, and therefore massDynamics must also be steady-state.");
            end if;

          annotation (preferredView="info",
          Documentation(info="<html>
<p>
This class contains parameters and medium properties
that are used in the lumped  volume model, and in models that extend the
lumped volume model.
</p>
<p>
These parameters are used for example by
<a href=\"modelica://IBPSA.Fluid.Interfaces.ConservationEquation\">
IBPSA.Fluid.Interfaces.ConservationEquation</a>,
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.MixingVolume\">
IBPSA.Fluid.MixingVolumes.MixingVolume</a> and
<a href=\"modelica://IBPSA.Fluid.HeatExchangers.Radiators.RadiatorEN442_2\">
IBPSA.Fluid.HeatExchangers.Radiators.RadiatorEN442_2</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
March 3, 2022, by Michael Wetter:<br/>
Moved <code>massDynamics</code> to <code>Advanced</code> tab,
added assertion for correct combination of energy and mass dynamics and
changed type from <code>record</code> to <code>block</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1542\">issue 1542</a>.
</li>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
November 9, 2018 by Michael Wetter:<br/>
Limited choices of media that are displayed in the pull down menu of
graphical editors.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">issue 1050</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>quantity=Medium.substanceNames</code> for <code>X_start</code>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
August 2, 2011, by Michael Wetter:<br/>
Set <code>substanceDynamics</code> and <code>traceDynamics</code> to final
and equal to <code>energyDynamics</code>,
as there is no need to make them different from <code>energyDynamics</code>.
</li>
<li>
August 1, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.DynamicFreeInitial</code> because
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code> leads
to high order DAE that Dymola cannot reduce.
</li>
<li>
July 31, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end LumpedVolumeDeclarations;

          partial model PartialTwoPort "Partial component with two ports"
            replaceable package Medium =
              Modelica.Media.Interfaces.PartialMedium "Medium in the component"
                annotation (choices(
                  choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
                  choice(redeclare package Medium = IBPSA.Media.Water "Water"),
                  choice(redeclare package Medium =
                      IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                        property_T=293.15,
                        X_a=0.40)
                        "Propylene glycol water, 40% mass fraction")));

            parameter Boolean allowFlowReversal = true
              "= false to simplify equations, assuming, but not enforcing, no flow reversal"
              annotation(Dialog(tab="Assumptions"), Evaluate=true);

            Modelica.Fluid.Interfaces.FluidPort_a port_a(
              redeclare final package Medium = Medium,
               m_flow(min=if allowFlowReversal then -Modelica.Constants.inf else 0),
               h_outflow(start = Medium.h_default, nominal = Medium.h_default))
              "Fluid connector a (positive design flow direction is from port_a to port_b)"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Fluid.Interfaces.FluidPort_b port_b(
              redeclare final package Medium = Medium,
              m_flow(max=if allowFlowReversal then +Modelica.Constants.inf else 0),
               h_outflow(start = Medium.h_default, nominal = Medium.h_default))
              "Fluid connector b (positive design flow direction is from port_a to port_b)"
              annotation (Placement(transformation(extent={{110,-10},{90,10}})));

            annotation (
              Documentation(info="<html>
<p>
This partial model defines an interface for components with two ports.
The treatment of the design flow direction and of flow reversal are predefined based on the parameter <code>allowFlowReversal</code>.
The component may transport fluid and may have internal storage for a given fluid <code>Medium</code>.
</p>
<h4>Implementation</h4>
<p>
This model is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>
but it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed parameters
<code>port_a_exposesState</code> and
<code>port_b_exposesState</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/351\">#351</a>
and
<code>showDesignFlowDirection</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
November 13, 2015, by Michael Wetter:<br/>
Assinged <code>start</code> attribute for leaving
enthalpy at <code>port_a</code> and <code>port_b</code>.
This was done to make the model similar to
<a href=\"modelica://IBPSA.Fluid.Interfaces.PartialFourPort\">
IBPSA.Fluid.Interfaces.PartialFourPort</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Removed import statement.
</li>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
Declared medium in ports to be <code>final</code>.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}}), graphics={
                  Polygon(
                    points={{20,-70},{60,-85},{20,-100},{20,-70}},
                    lineColor={0,128,255},
                    fillColor={0,128,255},
                    fillPattern=FillPattern.Solid,
                    visible=not allowFlowReversal),
                  Line(
                    points={{55,-85},{-60,-85}},
                    color={0,128,255},
                    visible=not allowFlowReversal),
                  Text(
                    extent={{-149,-114},{151,-154}},
                    textColor={0,0,255},
                    textString="%name")}));
          end PartialTwoPort;

          partial model PartialTwoPortInterface
            "Partial model with two ports and declaration of quantities that are used by many models"
            extends IBPSA.Fluid.Interfaces.PartialTwoPort(port_a(p(start=Medium.p_default)), port_b(p(start=Medium.p_default)));

            parameter Modelica.Units.SI.MassFlowRate m_flow_nominal
              "Nominal mass flow rate" annotation (Dialog(group="Nominal condition"));
            parameter Modelica.Units.SI.MassFlowRate m_flow_small(min=0) = 1E-4*abs(
              m_flow_nominal) "Small mass flow rate for regularization of zero flow"
              annotation (Dialog(tab="Advanced"));
            // Diagnostics
             parameter Boolean show_T = false
              "= true, if actual temperature at port is computed"
              annotation (
                Dialog(tab="Advanced", group="Diagnostics"),
                HideResult=true);

            Modelica.Units.SI.MassFlowRate m_flow(start=_m_flow_start) = port_a.m_flow
              "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";

            Modelica.Units.SI.PressureDifference dp(
              start=_dp_start,
              displayUnit="Pa") = port_a.p - port_b.p
              "Pressure difference between port_a and port_b";

            Medium.ThermodynamicState sta_a=
              if allowFlowReversal then
                Medium.setState_phX(port_a.p,
                                    noEvent(actualStream(port_a.h_outflow)),
                                    noEvent(actualStream(port_a.Xi_outflow)))
              else
                Medium.setState_phX(port_a.p,
                                    noEvent(inStream(port_a.h_outflow)),
                                    noEvent(inStream(port_a.Xi_outflow)))
                if show_T "Medium properties in port_a";

            Medium.ThermodynamicState sta_b=
              if allowFlowReversal then
                Medium.setState_phX(port_b.p,
                                    noEvent(actualStream(port_b.h_outflow)),
                                    noEvent(actualStream(port_b.Xi_outflow)))
              else
                Medium.setState_phX(port_b.p,
                                    noEvent(port_b.h_outflow),
                                    noEvent(port_b.Xi_outflow))
                 if show_T "Medium properties in port_b";

        protected
            final parameter Modelica.Units.SI.MassFlowRate _m_flow_start=0
              "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window";
            final parameter Modelica.Units.SI.PressureDifference _dp_start(displayUnit=
                  "Pa") = 0
              "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window";

            annotation (
              preferredView="info",
              Documentation(info="<html>
<p>
This component defines the interface for models with two fluid ports.
It is similar to
<a href=\"Modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>, but it does not
include the species balance
</p>
<pre>
  port_b.Xi_outflow = inStream(port_a.Xi_outflow);
</pre>
<p>
Thus, it can be used as a base class for a heat <i>and</i> mass transfer component
</p>
<p>
The partial model extends
<a href=\"modelica://IBPSA.Fluid.Interfaces.PartialTwoPort\">
IBPSA.Fluid.Interfaces.PartialTwoPort</a>
and adds quantities that are used by many models such as
<code>m_flow_nominal</code>, <code>m_flow</code> and <code>dp</code>.
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations. See for example
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 22, 2023, by Michael Wetter:<br/>
Improved documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1796\">IBPSA, #1796</a>.
</li>
<li>
February 2, 2022, by Hongxiang Fu:<br/>
If <code>allowFlowReversal==false</code>, replaced <code>actualStream()</code>
with <code>inStream()</code> for <code>sta_a</code> and
removed <code>actualStream()</code> for <code>sta_b</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1578\">IBPSA, #1578</a>.
</li>
<li>
March 30, 2021, by Michael Wetter:<br/>
Added annotation <code>HideResult=true</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1459\">IBPSA, #1459</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Renamed protected parameter <code>m_flow_start</code> to avoid
a name clash with
<a href=\"modelica://IBPSA.Fluid.Movers.FlowControlled_m_flow\">
IBPSA.Fluid.Movers.FlowControlled_m_flow</a>
which leads to an error as the definition were different,
and also renamed protected parameter <code>dp_start</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>
<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a</code> and <code>sta_b</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definition of <code>dp</code> because it causes some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Changed condition to remove <code>sta_a</code> to also
compute the state at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
March 11, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end PartialTwoPortInterface;

          model StaticTwoPortConservationEquation
            "Partial model for static energy and mass conservation equations"
            extends IBPSA.Fluid.Interfaces.PartialTwoPortInterface;

            constant Boolean simplify_mWat_flow = true
              "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

            constant Boolean prescribedHeatFlowRate = false
              "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";

            parameter Boolean use_mWat_flow = false
              "Set to true to enable input connector for moisture mass flow rate"
              annotation(Evaluate=true, Dialog(tab="Advanced"));

            parameter Boolean use_C_flow = false
              "Set to true to enable input connector for trace substance"
              annotation(Evaluate=true, Dialog(tab="Advanced"));

            Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
              "Sensible plus latent heat flow rate transferred into the medium"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
            Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                           unit="kg/s")
              if use_mWat_flow "Moisture mass flow rate added to the medium"
              annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
            Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow
              if use_C_flow "Trace substance mass flow rate added to the medium"
              annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

            // Outputs that are needed in models that extend this model
            Modelica.Blocks.Interfaces.RealOutput hOut(final unit="J/kg")
              "Leaving specific enthalpy of the component"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-50,110}), iconTransformation(
                  extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={-50,110})));

            Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                    each min=0,
                                                                    each max=1,
                                                                    nominal=0.01*ones(Medium.nXi))
              "Leaving species concentration of the component"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={0,110})));
            Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
              "Leaving trace substances of the component"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=90,
                  origin={50,110})));

        protected
            final parameter Boolean use_m_flowInv=
              (prescribedHeatFlowRate or use_mWat_flow or use_C_flow)
              "Flag, true if m_flowInv is used in the model"
              annotation (Evaluate=true);
            final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                      string2="Water",
                                                      caseSensitive=false)
                                                      then 1 else 0 for i in 1:Medium.nXi}
              "Vector with zero everywhere except where species is";

            Real m_flowInv(unit="s/kg") "Regularization of 1/m_flow of port_a";

            Modelica.Units.SI.MassFlowRate mXi_flow[Medium.nXi]
              "Mass flow rates of independent substances added to the medium";

            // Parameters for inverseXRegularized.
            // These are assigned here for efficiency reason.
            // Otherwise, they would need to be computed each time
            // the function is invocated.
            final parameter Real deltaReg = m_flow_small/1E3
              "Smoothing region for inverseXRegularized";

            final parameter Real deltaInvReg = 1/deltaReg
              "Inverse value of delta for inverseXRegularized";

            final parameter Real aReg = -15*deltaInvReg
              "Polynomial coefficient for inverseXRegularized";
            final parameter Real bReg = 119*deltaInvReg^2
              "Polynomial coefficient for inverseXRegularized";
            final parameter Real cReg = -361*deltaInvReg^3
              "Polynomial coefficient for inverseXRegularized";
            final parameter Real dReg = 534*deltaInvReg^4
              "Polynomial coefficient for inverseXRegularized";
            final parameter Real eReg = -380*deltaInvReg^5
              "Polynomial coefficient for inverseXRegularized";
            final parameter Real fReg = 104*deltaInvReg^6
              "Polynomial coefficient for inverseXRegularized";

            final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
                T=Medium.T_default,
                p=Medium.p_default,
                X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
            // Density at medium default values, used to compute the size of control volumes
            final parameter Modelica.Units.SI.SpecificHeatCapacity cp_default=
                Medium.specificHeatCapacityCp(state=state_default)
              "Specific heat capacity, used to verify energy conservation";
            constant Modelica.Units.SI.TemperatureDifference dTMax(min=1) = 200
              "Maximum temperature difference across the StaticTwoPortConservationEquation";
            // Conditional connectors
            Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
              "Needed to connect to conditional connector";
            Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
              "Needed to connect to conditional connector";
          initial equation
            // Assert that the substance with name 'water' has been found.
            if use_mWat_flow then
              assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
                "If Medium.nXi > 1, then substance 'water' must be present for one component.'"
                   + Medium.mediumName + "'.\n"
                   + "Check medium model.");
            end if;
          equation
            // Conditional connectors
            connect(mWat_flow, mWat_flow_internal);
            if not use_mWat_flow then
              mWat_flow_internal = 0;
            end if;

            connect(C_flow, C_flow_internal);
            if not use_C_flow then
              C_flow_internal = zeros(Medium.nC);
            end if;

            // Species flow rate from connector mWat_flow
            mXi_flow = mWat_flow_internal * s;

            // Regularization of m_flow around the origin to avoid a division by zero
            // m_flowInv is only used if prescribedHeatFlowRate == true, or
            // if the input connectors mWat_flow or C_flow are enabled.
            if use_m_flowInv then
              m_flowInv = IBPSA.Utilities.Math.Functions.inverseXRegularized(
                x=port_a.m_flow,
                delta=deltaReg,
                deltaInv=deltaInvReg,
                a=aReg,
                b=bReg,
                c=cReg,
                d=dReg,
                e=eReg,
                f=fReg);
            else
              // m_flowInv is not used.
              m_flowInv = 0;
            end if;

            if prescribedHeatFlowRate then
              assert(noEvent( abs(Q_flow) < dTMax*cp_default*max(m_flow_small/1E3, abs(m_flow))),
             "In " + getInstanceName() + ":
   The heat flow rate equals "           + String(Q_flow) +
             " W and the mass flow rate equals " + String(m_flow) + " kg/s,
   which results in a temperature difference "           +
             String(abs(Q_flow)/ (cp_default*max(m_flow_small/1E3, abs(m_flow)))) +
             " K > dTMax=" +String(dTMax) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
            end if;

            if allowFlowReversal then
              // Formulate hOut using spliceFunction. This avoids an event iteration.
              // The introduced error is small because deltax=m_flow_small/1e3
              hOut = IBPSA.Utilities.Math.Functions.regStep(
                y1=port_b.h_outflow,
                y2=port_a.h_outflow,
                x=port_a.m_flow,
                x_small=m_flow_small/1E3);
              XiOut = IBPSA.Utilities.Math.Functions.regStep(
                y1=port_b.Xi_outflow,
                y2=port_a.Xi_outflow,
                x=port_a.m_flow,
                x_small=m_flow_small/1E3);
              COut = IBPSA.Utilities.Math.Functions.regStep(
                y1=port_b.C_outflow,
                y2=port_a.C_outflow,
                x=port_a.m_flow,
                x_small=m_flow_small/1E3);
            else
              hOut =  port_b.h_outflow;
              XiOut = port_b.Xi_outflow;
              COut =  port_b.C_outflow;
            end if;

            //////////////////////////////////////////////////////////////////////////////////////////
            // Energy balance and mass balance

              // Mass balance (no storage)
              port_a.m_flow + port_b.m_flow = if simplify_mWat_flow then 0 else -mWat_flow_internal;

              // Substance balance
              // a) forward flow
              if use_m_flowInv then
                port_b.Xi_outflow = inStream(port_a.Xi_outflow) + mXi_flow * m_flowInv;
              else // no water is added
                assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for forward flow.");
                port_b.Xi_outflow = inStream(port_a.Xi_outflow);
              end if;

              // b) backward flow
              if allowFlowReversal then
                if use_m_flowInv then
                  port_a.Xi_outflow = inStream(port_b.Xi_outflow) - mXi_flow * m_flowInv;
                else // no water added
                  assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for reverse flow.");
                  port_a.Xi_outflow = inStream(port_b.Xi_outflow);
                end if;
              else // no  flow reversal
                port_a.Xi_outflow = Medium.X_default[1:Medium.nXi];
              end if;

              // Energy balance.
              // This equation is approximate since m_flow = port_a.m_flow is used for the mass flow rate
              // at both ports. Since mWat_flow_internal << m_flow, the error is small.
              if prescribedHeatFlowRate then
                port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
                if allowFlowReversal then
                  port_a.h_outflow = inStream(port_b.h_outflow) - Q_flow * m_flowInv;
                else
                  port_a.h_outflow = Medium.h_default;
                end if;
              else
                // Case with prescribedHeatFlowRate == false.
                // port_b.h_outflow is known and the equation needs to be solved for Q_flow.
                // Hence, we cannot use m_flowInv as for m_flow=0, any Q_flow would satisfiy
                // Q_flow * m_flowInv = 0.
                // The same applies for port_b.Xi_outflow and mXi_flow.
                port_a.m_flow * (inStream(port_a.h_outflow) - port_b.h_outflow)     = -Q_flow;
                if allowFlowReversal then
                  port_a.m_flow * (inStream(port_b.h_outflow)  - port_a.h_outflow)  = +Q_flow;
                else
                  // When allowFlowReversal = false, the downstream enthalpy does not matter.
                  // Therefore a dummy value is used to avoid algebraic loops
                  port_a.h_outflow = Medium.h_default;
                end if;
              end if;

            // Transport of trace substances
            if use_m_flowInv and use_C_flow then
              port_b.C_outflow =  inStream(port_a.C_outflow) + C_flow_internal * m_flowInv;
            else // no trace substance added.
              assert(not use_C_flow, "In " + getInstanceName() + ": Wrong implementation of trace substance balance for forward flow.");
              port_b.C_outflow =  inStream(port_a.C_outflow);
            end if;

            if allowFlowReversal then
              if use_C_flow then
                port_a.C_outflow = inStream(port_b.C_outflow) - C_flow_internal * m_flowInv;
              else
                port_a.C_outflow = inStream(port_b.C_outflow);
              end if;
            else
              port_a.C_outflow = zeros(Medium.nC);
            end if;

            ////////////////////////////////////////////////////////////////////////////
            // No pressure drop in this model
            port_a.p = port_b.p;

            annotation (
              preferredView="info",
              Documentation(info="<html>
<p>
This model transports fluid between its two ports, without storing mass or energy.
It implements a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>

<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
<h4>Implementation</h4>
<p>
Input connectors of the model are
</p>
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can only be used as a steady-state model with two fluid ports.
For a model with a dynamic balance, and more fluid ports, use
<a href=\"modelica://IBPSA.Fluid.Interfaces.ConservationEquation\">
IBPSA.Fluid.Interfaces.ConservationEquation</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
October 24, 2022, by Michael Wetter:<br/>
Conditionally removed assertion that checks for water content as this is
only required if water is added to the medium.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1650\">#1650</a>.
</li>
<li>
September 9, 2022, by Michael Wetter:<br/>
Set nominal attribute for <code>XiOut</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1634\">1634</a>.
</li>
<li>
September 18, 2020, by Michael Wetter:<br/>
Removed start value for <code>hOut</code> as it will be set by
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume\">
IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume</a>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1397\">#1397</a>.
</li>
<li>
February 12, 2019, by Filip Jorissen:<br/>
Removed obsolete division by <code>TMax</code> in assert.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1097\">#1097</a>.
</li>
<li>
June 23, 2018, by Filip Jorissen:<br/>
Added more details to energy conservation assert to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/962\">#962</a>.
</li>
<li>
March 30, 2018, by Filip Jorissen:<br/>
Added <code>getInstanceName()</code> in asserts to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/901\">#901</a>.
</li>
<li>
April 24, 2017, by Michael Wetter and Filip Jorissen:<br/>
Reimplemented check for energy conversion.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 24, 2017, by Michael Wetter:<br/>
Reverted change from April 21, 2017.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 21, 2017, by Filip Jorissen:<br/>
Revised test for energy conservation at small mass flow rates.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
October 23, 2016, by Filip Jorissen:<br/>
Added test for energy conservation at small mass flow rates.
</li>
<li>
March 17, 2016, by Michael Wetter:<br/>
Refactored model and implmented <code>regStep</code> instead of <code>spliceFunction</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>
and for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a>.
</li>
<li>
September 3, 2015, by Filip Jorissen:<br/>
Revised implementation of conservation of vapor mass.
Added new variable <code>mFlow_inv_b</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Removed <code>constant sensibleOnly</code> as this is no longer used because
the model uses <code>use_mWat_flow</code>.<br/>
Changed condition that determines whether <code>m_flowInv</code> needs to be
computed because the change from January 20 introduced an error in
<a href=\"modelica://IBPSA.Fluid.MassExchangers.Examples.ConstantEffectiveness\">
IBPSA.Fluid.MassExchangers.Examples.ConstantEffectiveness</a>.
</li>
<li>
January 20, 2016, by Filip Jorissen:<br/>
Removed if-else block in code for parameter <code>sensibleOnly</code>
since this is no longer needed to simplify the equations.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
September 14, 2015, by Filip Jorissen:<br/>
Rewrote some equations for better readability.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
Refactored implementation of
<a href=\"modelica://IBPSA.Utilities.Math.Functions.inverseXRegularized\">
IBPSA.Utilities.Math.Functions.inverseXRegularized</a>
to allow function to be inlined and to factor out the computation
of arguments that only depend on parameters.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Corrected bug for situation with latent heat exchange and flow reversal not
allowed.
The previous formulation was singular.
This caused some models to not translate.
The error was introduced in
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Revised implementation so that equations are always consistent
and do not lead to division by zero,
also when connecting a <code>prescribedHeatFlowRate</code>
to <code>MixingVolume</code> instances.
Renamed <code>use_safeDivision</code> into <code>prescribedHeatFlowRate</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>
for a discussion.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Corrected sign error in the equation that is used if <code>use_safeDivision=false</code>
and <code>sensibleOnly=true</code>.
This only affects internal numerical tests, but not any examples in the library
as the constant <code>use_safeDivision</code> is set to <code>true</code> by default.
</li>
<li>
September 25, 2013 by Michael Wetter:<br/>
Reformulated computation of outlet properties to avoid an event at zero mass flow rate.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.
</li>
<li>
May 7, 2013 by Michael Wetter:<br/>
Removed <code>for</code> loops for species balance and trace substance balance,
as they cause the error <code>Error: Operand port_a.Xi_outflow[1] to operator inStream is not a stream variable.</code>
in OpenModelica.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
June 22, 2012 by Michael Wetter:<br/>
Reformulated implementation with <code>m_flowInv</code> to use <code>port_a.m_flow * ...</code>
if <code>use_safeDivision=false</code>. This avoids a division by zero if
<code>port_a.m_flow=0</code>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IBPSA.Fluid.Interfaces</code>.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(
                  preserveAspectRatio=true,
                  extent={{-100,-100},{100,100}},
                  grid={1,1}), graphics={Rectangle(
                    extent={{-100,100},{100,-100}},
                    fillColor={135,135,135},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-93,72},{-58,89}},
                    textColor={0,0,127},
                    textString="Q_flow"),
                  Text(
                    extent={{-93,37},{-58,54}},
                    textColor={0,0,127},
                    textString="mWat_flow"),
                  Text(
                    extent={{-41,103},{-10,117}},
                    textColor={0,0,127},
                    textString="hOut"),
                  Text(
                    extent={{10,103},{41,117}},
                    textColor={0,0,127},
                    textString="XiOut"),
                  Text(
                    extent={{61,103},{92,117}},
                    textColor={0,0,127},
                    textString="COut"),
                  Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
                  Polygon(
                    points={{-42,67},{-50,45},{-34,45},{-42,67}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{87,-73},{65,-65},{65,-81},{87,-73}},
                    lineColor={255,255,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
                  Line(points={{6,14},{6,-37}},     color={255,255,255}),
                  Line(points={{54,14},{6,14}},     color={255,255,255}),
                  Line(points={{6,-37},{-42,-37}},  color={255,255,255})}));
          end StaticTwoPortConservationEquation;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains basic classes that are used to build
component models that change the state of the
fluid. The classes are not directly usable, but can
be extended when building a new model.
</p>
</html>"));
        end Interfaces;

        package BaseClasses "Package with base classes for IBPSA.Fluid"
          extends Modelica.Icons.BasesPackage;

          partial model PartialResistance "Partial model for a hydraulic resistance"
              extends IBPSA.Fluid.Interfaces.PartialTwoPortInterface(
              show_T=false,
              dp(nominal=if dp_nominal_pos > Modelica.Constants.eps then dp_nominal_pos else 1),
              m_flow(nominal=if m_flow_nominal_pos > Modelica.Constants.eps then m_flow_nominal_pos else 1),
              final m_flow_small=1E-4*abs(m_flow_nominal));

            constant Boolean homotopyInitialization = true "= true, use homotopy method"
              annotation(HideResult=true);

            parameter Boolean from_dp = false
              "= true, use m_flow = f(dp) else dp = f(m_flow)"
              annotation (Evaluate=true, Dialog(tab="Advanced"));

            parameter Modelica.Units.SI.PressureDifference dp_nominal(displayUnit="Pa")
              "Pressure drop at nominal mass flow rate"
              annotation (Dialog(group="Nominal condition"));

            parameter Boolean linearized = false
              "= true, use linear relation between m_flow and dp for any flow rate"
              annotation(Evaluate=true, Dialog(tab="Advanced"));

            parameter Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
              "Turbulent flow if |m_flow| >= m_flow_turbulent";

        protected
            parameter Medium.ThermodynamicState sta_default=
               Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
            parameter Modelica.Units.SI.DynamicViscosity eta_default=
                Medium.dynamicViscosity(sta_default)
              "Dynamic viscosity, used to compute transition to turbulent flow regime";

            final parameter Modelica.Units.SI.MassFlowRate m_flow_nominal_pos=abs(
                m_flow_nominal) "Absolute value of nominal flow rate";
            final parameter Modelica.Units.SI.PressureDifference dp_nominal_pos(
                displayUnit="Pa") = abs(dp_nominal)
              "Absolute value of nominal pressure difference";
          initial equation
            assert(homotopyInitialization, "In " + getInstanceName() +
              ": The constant homotopyInitialization has been modified from its default value. This constant will be removed in future releases.",
              level = AssertionLevel.warning);

          equation
            // Isenthalpic state transformation (no storage and no loss of energy)
            port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
            port_b.h_outflow = inStream(port_a.h_outflow);

            // Mass balance (no storage)
            port_a.m_flow + port_b.m_flow = 0;

            // Transport of substances
            port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
            port_b.Xi_outflow = inStream(port_a.Xi_outflow);

            port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
            port_b.C_outflow = inStream(port_a.C_outflow);

            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,40},{100,-40}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={192,192,192}),
                  Rectangle(
                    extent={{-100,22},{100,-24}},
                    lineColor={0,0,0},
                    fillPattern=FillPattern.HorizontalCylinder,
                    fillColor={0,127,255}),
                  Rectangle(
                    visible=linearized,
                    extent={{-100,22},{100,-22}},
                    fillPattern=FillPattern.Backward,
                    fillColor={0,128,255},
                    pattern=LinePattern.None,
                    lineColor={255,255,255}),
                  Rectangle(
                    extent=DynamicSelect({{-100,10},{-100,10}}, {{100,10},{100+200*max(-1, min(0, m_flow/(abs(m_flow_nominal)))),-10}}),
                    lineColor={28,108,200},
                    fillColor={255,0,0},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Rectangle(
                    extent=DynamicSelect({{-100,10},{-100,10}}, {{-100,10},{-100+200*min(1, max(0, m_flow/abs(m_flow_nominal))),-10}}),
                    lineColor={28,108,200},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None)}),
                    defaultComponentName="res",
          Documentation(info="<html>
<p>
Partial model for a flow resistance, possible with variable flow coefficient.
Models that extend this class need to implement an equation that relates
<code>m_flow</code> and <code>dp</code>, and they need to assign the parameter
<code>m_flow_turbulent</code>.
</p>
<p>
See for example
<a href=\"modelica://IBPSA.Fluid.FixedResistances.PressureDrop\">
IBPSA.Fluid.FixedResistances.PressureDrop</a> for a model that extends
this base class.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Changed <code>homotopyInitialization</code> to a constant.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1341\">IBPSA, #1341</a>.
</li>
<li>
February 26, 2020, by Michael Wetter:<br/>
Changed icon to display its operating state.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1294\">#1294</a>.
</li>
<li>
October 25, 2019, by Jianjun Hu:<br/>
Improved icon graphics annotation. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1225\">#1225</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start value for pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Avoided assignment of <code>dp(nominal=0)</code> if <code>dp_nominal_pos = 0</code>
and of <code>m_flow(nominal=0)</code> if <code>m_flow_nominal_pos = 0</code>
as nominal values are not allowed to be zero.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>,
<code>port_a.h_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">#281</a>.
</li>
<li>
January 13, 2015, by Marcus Fuchs:<br/>
Revised revisions section (there were two revisions statements)
</li>
<li>
November 20, 2014 by Michael Wetter:<br/>
Removed <code>start</code> attribute for <code>m_flow</code>
as this is already set in its base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to base class as it has no longer this parameter.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
February 12, 2012, by Michael Wetter:<br/>
Removed duplicate declaration of <code>m_flow_nominal</code>.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Made assignment of <code>m_flow_small</code> <code>final</code> as it is no
longer used in the base class.
</li>
<li>
January 16, 2012, by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IBPSA.Fluid.BaseClasses.PartialResistance</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IBPSA.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 5, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
June 20, 2011, by Michael Wetter:<br/>
Set start values for <code>m_flow</code> and <code>dp</code> to zero, since
most HVAC systems start at zero flow. With this change, the start values
appear in the GUI and can be set by the user.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>m_flow_nominal_pos</code> and <code>dp_nominal_pos</code> to allow
providing negative nominal values which will be used, for example, to set start
values of flow splitters which may have negative flow rates and pressure drop
at the initial condition.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 23, 2011 by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 30, 2010 by Michael Wetter:<br/>
Changed base classes to allow easier initialization.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Extracted pressure drop computation and implemented it in the
new model
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.BasicFlowModel\">
IBPSA.Fluid.BaseClasses.FlowModels.BasicFlowModel</a>.
</li>
<li>
September 18, 2008, by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end PartialResistance;

          package FlowModels "Flow models for pressure drop calculations"
            extends Modelica.Icons.BasesPackage;

            function basicFlowFunction_dp
              "Function that computes mass flow rate for given pressure drop"

              input Modelica.Units.SI.PressureDifference dp(displayUnit="Pa")
                "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
              input Real k(min=0, unit="")
                "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
              input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
                "Mass flow rate where transition to turbulent flow occurs";
              output Modelica.Units.SI.MassFlowRate m_flow
                "Mass flow rate in design flow direction";
          protected
              Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
                "Pressure where flow changes to turbulent";
              Real dpNorm=dp/dp_turbulent
                "Normalised pressure difference";
              Real dpNormSq=dpNorm^2
                "Square of normalised pressure difference";
            algorithm
               m_flow := smooth(2, if noEvent(abs(dp)>dp_turbulent)
                           then sign(dp)*k*sqrt(abs(dp))
                           else (1.40625  + (0.15625*dpNormSq - 0.5625)*dpNormSq)*m_flow_turbulent*dpNorm);
              annotation(Inline=false,
                       smoothOrder=2,
                       derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                         IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der,
                       inverse(dp=IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                         m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent)),
                       Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                        {100,100}}), graphics={Line(
                      points={{-80,-40},{-80,60},{80,-40},{80,60}},
                      color={0,0,255},
                      thickness=1), Text(
                      extent={{-40,-40},{40,-80}},
                      textColor={0,0,0},
                      fillPattern=FillPattern.Sphere,
                      fillColor={232,0,0},
                      textString="%name")}),
            Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m&#775; = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m&#775; &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",             revisions="<html>
<ul>
<li>
November 9, 2019, by Filip Jorissen:<br/>
Added <code>smooth(2, . )</code> for avoiding
a warning in the check valve model.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1240\">#1240</a>.
</li>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
March 19, 2016, by Michael Wetter:<br/>
Added <code>abs</code> function for
<code>IBPSA.Fluid.FixedResistances.Validation.PressureDropsExplicit</code>
to work in OpenModelica.
See <a href=\"https://trac.openmodelica.org/OpenModelica/ticket/3778\">
OpenModelica ticket 3778</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
January 9, 2014, by Michael Wetter:<br/>
Correct revision section, of which there were two.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>m_flow=0</code> if <code>dp=0</code>,
as this causes the derivative to be discontinuous at <code>dp=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2010 by Michael Wetter:<br/>
Changed implementation to allow <code>k=0</code>, which is
the case for a closed valve with no leakage
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end basicFlowFunction_dp;

            function basicFlowFunction_dp_der
              "1st derivative of function that computes mass flow rate for given pressure drop"
              extends Modelica.Icons.Function;

              input Modelica.Units.SI.PressureDifference dp(displayUnit="Pa")
                "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
              input Real k(min=0, unit="")
                "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
              input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
                "Mass flow rate where transition to turbulent flow occurs";
              input Real dp_der
                "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
              output Real m_flow_der(unit="kg/s2")
                "Derivative of mass flow rate in design flow direction";
          protected
              Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
                "Pressure where flow changes to turbulent";
              Real dpNormSq=(dp/dp_turbulent)^2
                "Square of normalised pressure difference";
            algorithm
             m_flow_der := (if noEvent(abs(dp)>dp_turbulent)
                            then 0.5*k/sqrt(abs(dp))
                            else (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*m_flow_turbulent/dp_turbulent)*dp_der;
             annotation (Inline=false,
                         smoothOrder=1,
                         derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                           IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2,
            Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",   revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
April 14, 2017, by Filip Jorissen:<br/>
Changed implementation such that it cannot lead to square roots
of negative numbers and reduced the number of required operations.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/723\">#723</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
            end basicFlowFunction_dp_der;

            function basicFlowFunction_dp_der2
              "2nd derivative of flow function2nd derivative of function that computes mass flow rate for given pressure drop"
              extends Modelica.Icons.Function;

              input Modelica.Units.SI.PressureDifference dp(displayUnit="Pa")
                "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
              input Real k(min=0, unit="")
                "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
              input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
                "Mass flow rate where transition to turbulent flow occurs";
              input Real dp_der
                "1st derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
              input Real dp_der2
                "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
              output Real m_flow_der2
                "2nd derivative of mass flow rate in design flow direction";
          protected
              Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
                "Pressure where flow changes to turbulent";
              Real dpNorm=dp/dp_turbulent
                "Normalised pressure difference";
              Real dpNormSq=dpNorm^2
                "Square of normalised pressure difference";
            algorithm
             m_flow_der2 := if noEvent(abs(dp)>dp_turbulent)
                             then 0.5*k/sqrt(abs(dp))*(-0.5/dp * dp_der^2 + dp_der2)
                             else m_flow_turbulent/dp_turbulent*(
                                   (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*dp_der2
                                 + (-3.375 + 3.125*dpNormSq)*dpNorm/dp_turbulent*dp_der^2);

             annotation (smoothOrder=0,
             Inline=false,
            Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",   revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
            end basicFlowFunction_dp_der2;

            function basicFlowFunction_m_flow
              "Function that computes pressure drop for given mass flow rate"

              input Modelica.Units.SI.MassFlowRate m_flow
                "Mass flow rate in design flow direction";
              input Real k(unit="")
                "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
              input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
                "Mass flow rate where transition to turbulent flow occurs";
              output Modelica.Units.SI.PressureDifference dp(displayUnit="Pa")
                "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          protected
              Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
                "Pressure where flow changes to turbulent";
              Real m_flowNorm = m_flow/m_flow_turbulent
                "Normalised mass flow rate";
              Real m_flowNormSq = m_flowNorm^2
                "Square of normalised mass flow rate";

            algorithm
             dp := smooth(2, if noEvent(abs(m_flow)>m_flow_turbulent)
                  then sign(m_flow)*(m_flow/k)^2
                  else (0.375 + (0.75-0.125*m_flowNormSq)*m_flowNormSq)*dp_turbulent*m_flowNorm);

             annotation (Inline=false,
                         smoothOrder=2,
                         derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                           IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der,
                         inverse(m_flow=IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                           dp=dp, k=k, m_flow_turbulent=m_flow_turbulent)),
                         Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                        -100},{100,100}}), graphics={Line(
                      points={{-80,-40},{-80,60},{80,-40},{80,60}},
                      color={0,0,255},
                      thickness=1), Text(
                      extent={{-40,-40},{40,-80}},
                      textColor={0,0,0},
                      fillPattern=FillPattern.Sphere,
                      fillColor={232,0,0},
                      textString="%name")}),
            Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = sign(m&#775;) (m&#775; &frasl; k)<sup>2</sup>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m&#775; &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",   revisions="<html>
<ul>
<li>
December 9, 2019, by Michael Wetter:<br/>
Added <code>smooth(2, . )</code>, similar to
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1240\">#1240</a>.
</li>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>dp=0</code> if <code>m_flow=0</code>,
as this causes the derivative to be discontinuous at <code>m_flow=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end basicFlowFunction_m_flow;

            function basicFlowFunction_m_flow_der
              "1st derivative of function that computes pressure drop for given mass flow rate"
              extends Modelica.Icons.Function;

              input Modelica.Units.SI.MassFlowRate m_flow
                "Mass flow rate in design flow direction";
              input Real k(unit="")
                "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
              input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
                "Mass flow rate where transition to turbulent flow occurs";
              input Real m_flow_der(unit="kg/s2")
                "Derivative of mass flow rate in design flow direction";
              output Real dp_der
                "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          protected
              Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
                "Pressure where flow changes to turbulent";
              Real m_flowNormSq = (m_flow/m_flow_turbulent)^2
                "Square of normalised mass flow rate";
            algorithm
             dp_der :=(if noEvent(abs(m_flow)>m_flow_turbulent)
                       then sign(m_flow)*2*m_flow/k^2
                       else (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*dp_turbulent/m_flow_turbulent)*m_flow_der;

             annotation (Inline=false,
                         smoothOrder=1,
                         derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                         IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2,
            Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",   revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
            end basicFlowFunction_m_flow_der;

            function basicFlowFunction_m_flow_der2
              "2nd derivative of function that computes pressure drop for given mass flow rate"
              extends Modelica.Icons.Function;

              input Modelica.Units.SI.MassFlowRate m_flow
                "Mass flow rate in design flow direction";
              input Real k(unit="")
                "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
              input Modelica.Units.SI.MassFlowRate m_flow_turbulent(min=0)
                "Mass flow rate where transition to turbulent flow occurs";
              input Real m_flow_der(unit="kg/s2")
                "1st derivative of mass flow rate in design flow direction";
              input Real m_flow_der2(unit="kg/s3")
                "2nd derivative of mass flow rate in design flow direction";
              output Real dp_der2
                "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          protected
              Modelica.Units.SI.PressureDifference dp_turbulent=(m_flow_turbulent/k)^2
                "Pressure where flow changes to turbulent";
              Real m_flowNorm = m_flow/m_flow_turbulent
                "Normalised mass flow rate";
              Real m_flowNormSq = m_flowNorm^2
                "Square of normalised mass flow rate";
            algorithm
             dp_der2 :=if noEvent(abs(m_flow)>m_flow_turbulent)
                       then sign(m_flow)*2/k^2 * (m_flow_der^2 + m_flow * m_flow_der2)
                       else dp_turbulent/m_flow_turbulent*(
                             (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*m_flow_der2
                           + (4.5 - 2.5*m_flowNormSq)*m_flowNorm/m_flow_turbulent*m_flow_der^2);

             annotation (smoothOrder=0,
             Inline=false,
            Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",   revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end basicFlowFunction_m_flow_der2;
          annotation (Documentation(info="<html>
<p>
This package contains a basic flow model that is used by the
various models that compute pressure drop.
</p>
<h4>Assumption and limitations</h4>
<p>
Because the density does not change signficantly in heating,
ventilation and air conditioning systems for buildings,
the flow models compute the pressure drop based on the mass flow
rate and not the volume flow rate. This typically leads to simpler
equations because it does not require
the mass density, which changes when the flow is reversed.
Although, for conceptual design of building energy system, there is
in general not enough information available that would warrant a more
detailed pressure drop calculation.
If a more detailed computation of the flow resistance is needed,
then a user can use models from the
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a> library.
</p>
<p>
All functions have an argument <code>m_flow_turbulent</code> that determines where the
flow transitions to fully turbulent flow. For smaller mass flow rates,
the quadratic relation is replaced by a function that has finite slope
near zero pressure drop. This is done for numerical reasons, and to approximate
laminar flow, although the implementation does not use a linear function.
</p>
<h4>Implementation</h4>
<p>
The two main functions are
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
and
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
that compute the mass flow rate or the pressure drop, respectively.
Both functions are two times continuously differentiable.
First and second order derivatives are provided
in the function that have the suffix <code>_der</code> and <code>_der2</code>.
</p>
</html>",           revisions="<html>
<ul>
<li>
April 10, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end FlowModels;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Fluid\">IBPSA.Fluid</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (
      preferredView="info", Documentation(info="<html>
This package contains components for fluid flow systems such as
pumps, valves and sensors. For other fluid flow models, see
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a>.
</html>"),
      Icon(graphics={
              Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}},
                  lineColor={0,0,0}),
              Line(points={{2,42},{2,-10}}),
              Rectangle(
                extent={{-18,50},{22,42}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}));
      end Fluid;

      package Media "Package with medium models"
        extends Modelica.Icons.Package;

        package Air
          "Package with moist air model that decouples pressure and temperature"
          extends Modelica.Media.Interfaces.PartialCondensingGases(
             mediumName="Air",
             final substanceNames={"water", "air"},
             final reducedX=true,
             final singleState = false,
             reference_X={0.01,0.99},
             final fluidConstants = {Modelica.Media.IdealGases.Common.FluidData.H2O,
                                     Modelica.Media.IdealGases.Common.FluidData.N2},
             reference_T=273.15,
             reference_p=101325,
             AbsolutePressure(start=p_default),
             Temperature(start=T_default));
          extends Modelica.Icons.Package;

          constant Integer Water=1
            "Index of water (in substanceNames, massFractions X, etc.)";
          constant Integer Air=2
            "Index of air (in substanceNames, massFractions X, etc.)";

          // In the assignments below, we compute cv as OpenModelica
          // cannot evaluate cv=cp-R as defined in GasProperties.
          constant GasProperties dryair(
            R=Modelica.Media.IdealGases.Common.SingleGasesData.Air.R_s,
            MM=Modelica.Media.IdealGases.Common.SingleGasesData.Air.MM,
            cp=IBPSA.Utilities.Psychrometrics.Constants.cpAir,
            cv=IBPSA.Utilities.Psychrometrics.Constants.cpAir - Modelica.Media.IdealGases.Common.SingleGasesData.Air.R_s)
            "Dry air properties";
          constant GasProperties steam(
            R=Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R_s,
            MM=Modelica.Media.IdealGases.Common.SingleGasesData.H2O.MM,
            cp=IBPSA.Utilities.Psychrometrics.Constants.cpSte,
            cv=IBPSA.Utilities.Psychrometrics.Constants.cpSte - Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R_s)
            "Steam properties";

          constant Real k_mair =  steam.MM/dryair.MM "Ratio of molar weights";

          constant Modelica.Units.SI.MolarMass[2] MMX={steam.MM,dryair.MM}
            "Molar masses of components";

          constant AbsolutePressure pStp = reference_p
            "Pressure for which fluid density is defined";
          constant Density dStp = 1.2 "Fluid density at pressure pStp";

          // Redeclare ThermodynamicState to avoid the warning
          // "Base class ThermodynamicState is replaceable"
          // during model check
          redeclare record extends ThermodynamicState
            "ThermodynamicState record for moist air"
          end ThermodynamicState;
          // There must not be any stateSelect=StateSelect.prefer for
          // the pressure.
          // Otherwise, translateModel("IBPSA.Fluid.FMI.ExportContainers.Examples.FMUs.ResistanceVolume")
          // will fail as Dymola does an index reduction and outputs
          //   Differentiated the equation
          //   vol.dynBal.medium.p+res.dp-inlet.p = 0.0;
          //   giving
          //   der(vol.dynBal.medium.p)+der(res.dp) = der(inlet.p);
          //
          //   The model requires derivatives of some inputs as listed below:
          //   1 inlet.m_flow
          //   1 inlet.p
          // Therefore, the statement
          //   p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
          // has been removed.
          redeclare replaceable model BaseProperties "Base properties (p, d, T, h, u, R, MM and X and Xi) of a medium"

          parameter Boolean preferredMediumStates=false
            "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
            annotation (Evaluate=true, Dialog(tab="Advanced"));
          final parameter Boolean standardOrderComponents=true
            "If true, and reducedX = true, the last element of X will be computed from the other ones";

          InputAbsolutePressure p "Absolute pressure of medium";
          InputMassFraction[1] Xi(
            start=reference_X[1:1],
            nominal={0.01},
            each stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
            "Structurally independent mass fractions";
          InputSpecificEnthalpy h "Specific enthalpy of medium";
          Modelica.Media.Interfaces.Types.Density d "Density of medium";
          Modelica.Media.Interfaces.Types.Temperature T(
           stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
           "Temperature of medium";
          Modelica.Media.Interfaces.Types.MassFraction[2] X(start=reference_X)
            "Mass fractions (= (component mass)/total mass  m_i/m)";
          Modelica.Media.Interfaces.Types.SpecificInternalEnergy u
            "Specific internal energy of medium";
          Modelica.Media.Interfaces.Types.SpecificHeatCapacity R_s
            "Gas constant (of mixture if applicable)";
          Modelica.Media.Interfaces.Types.MolarMass MM
            "Molar mass (of mixture or single fluid)";
          ThermodynamicState state
            "Thermodynamic state record for optional functions";

            Modelica.Units.NonSI.Temperature_degC T_degC=
                Modelica.Units.Conversions.to_degC(T) "Temperature of medium in [degC]";
            Modelica.Units.NonSI.Pressure_bar p_bar=Modelica.Units.Conversions.to_bar(p)
              "Absolute pressure of medium in [bar]";

          // Local connector definition, used for equation balancing check
          connector InputAbsolutePressure = input Modelica.Units.SI.AbsolutePressure
            "Pressure as input signal connector";
          connector InputSpecificEnthalpy = input Modelica.Units.SI.SpecificEnthalpy
            "Specific enthalpy as input signal connector";
          connector InputMassFraction = input Modelica.Units.SI.MassFraction
            "Mass fraction as input signal connector";

            // Declarations for Air only
        protected
            Modelica.Units.SI.TemperatureDifference dT(start=T_default - reference_T)
              "Temperature difference used to compute enthalpy";

          equation
            MM = 1/(X[1]/steam.MM+(X[2])/dryair.MM);

            dT = T - reference_T;
            h = dT*dryair.cp * X[2] +
               (dT * steam.cp + h_fg) * X[1];
            R_s = dryair.R*X[2] + steam.R*X[1];

            // Equation for ideal gas, from h=u+p*v and R*T=p*v, from which follows that  u = h-R*T.
            // u = h-R*T;
            // However, in this medium, the gas law is d/dStp=p/pStp, from which follows using h=u+pv that
            // u= h-p*v = h-p/d = h-pStp/dStp
            u = h-pStp/dStp;

            // In this medium model, the density depends only
            // on temperature, but not on pressure.
            //  d = p/(R*T);
            d/dStp = p/pStp;

            state.p = p;
            state.T = T;
            state.X = X;

            X[1] = Xi[1];
            X[2] = 1 - X[1];

            // Assertions to test for bounds
            assert(noEvent(X[1] >= -1.e-5) and noEvent(X[1] <= 1 + 1.e-5), "Mass fraction X[1] = " + String(X[1]) + " of substance water"
              + "\nof medium \"IBPSA.Media.Air\" is not in the range 0..1");

            assert(noEvent(T >= 200.0), "In "   + getInstanceName() + ": Temperature T exceeded its minimum allowed value of -73.15 degC (200 Kelvin)
as required from medium model \"IBPSA.Media.Air\".");
            assert(noEvent(T <= 423.15), "In "   + getInstanceName() + ": Temperature T exceeded its maximum allowed value of 150 degC (423.15 Kelvin)
as required from medium model \"IBPSA.Media.Air\".");

          assert(noEvent(p >= 0.0), "Pressure (= " + String(p) + " Pa) of medium \"IBPSA.Media.Air\" is negative\n(Temperature = " + String(T) + " K)");
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}), Text(
                  extent={{-152,164},{152,102}},
                  textString="%name",
                  textColor={0,0,255})}), Documentation(info="<html>
<p>
Model with basic thermodynamic properties.
</p>
<p>
This model provides equation for the following thermodynamic properties:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" summary=\"Thermodynamic properties\">
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>absolute pressure</td></tr>
  <tr><td>d</td>
      <td>kg/m3</td>
      <td>density</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>Xi[nXi]</td>
      <td>kg/kg</td>
      <td>independent mass fractions m_i/m</td></tr>
  <tr><td>R</td>
      <td>J/kg.K</td>
      <td>gas constant</td></tr>
  <tr><td>M</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
</html>",         revisions="<html>
<ul>
<li>
September 22, 2020, by Michael Wetter:<br/>
First implementation based on Modelica Standard Library,
but with <code>noEvent</code> added to check of bounds.
</li>
</ul>
</html>"));
          end BaseProperties;

        redeclare function density "Gas density"
          extends Modelica.Icons.Function;
          input ThermodynamicState state;
          output Density d "Density";
        algorithm
          d :=state.p*dStp/pStp;
          annotation(smoothOrder=5,
          Inline=true,
          Documentation(info="<html>
Density is computed from pressure, temperature and composition in the thermodynamic state record applying the ideal gas law.
</html>"));
        end density;

        redeclare function extends dynamicViscosity
            "Return the dynamic viscosity of dry air"
        algorithm
          eta := 4.89493640395e-08 * state.T + 3.88335940547e-06;
          annotation (
          smoothOrder=99,
          Inline=true,
        Documentation(info="<html>
<p>
This function returns the dynamic viscosity.
</p>
<h4>Implementation</h4>
<p>
The function is based on the 5th order polynomial
of
<a href=\"modelica://Modelica.Media.Air.MoistAir.dynamicViscosity\">
Modelica.Media.Air.MoistAir.dynamicViscosity</a>.
However, for the typical range of temperatures encountered
in building applications, a linear function sufficies.
This implementation is therefore the above 5th order polynomial,
linearized around <i>20</i>&deg;C.
The relative error of this linearization is
<i>0.4</i>% at <i>-20</i>&deg;C,
and less then
<i>0.2</i>% between  <i>-5</i>&deg;C and  <i>+50</i>&deg;C.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 19, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end dynamicViscosity;

        redeclare function enthalpyOfCondensingGas
            "Enthalpy of steam per unit mass of steam"
          extends Modelica.Icons.Function;

          input Temperature T "temperature";
          output SpecificEnthalpy h "steam enthalpy";
        algorithm
          h := (T-reference_T) * steam.cp + h_fg;
          annotation(smoothOrder=5,
          Inline=true,
          derivative=der_enthalpyOfCondensingGas);
        end enthalpyOfCondensingGas;

        redeclare replaceable function extends enthalpyOfGas
            "Enthalpy of gas mixture per unit mass of gas mixture"
        algorithm
          h := enthalpyOfCondensingGas(T)*X[Water]
               + enthalpyOfDryAir(T)*(1.0-X[Water]);
        annotation (
          Inline=true);
        end enthalpyOfGas;

        redeclare replaceable function extends enthalpyOfLiquid
            "Enthalpy of liquid (per unit mass of liquid) which is linear in the temperature"
        algorithm
          h := (T - reference_T)*cpWatLiq;
          annotation (
            smoothOrder=5,
            Inline=true,
            derivative=der_enthalpyOfLiquid);
        end enthalpyOfLiquid;

        redeclare function enthalpyOfNonCondensingGas
            "Enthalpy of non-condensing gas per unit mass of steam"
          extends Modelica.Icons.Function;

          input Temperature T "temperature";
          output SpecificEnthalpy h "enthalpy";
        algorithm
          h := enthalpyOfDryAir(T);
          annotation (
          smoothOrder=5,
          Inline=true,
          derivative=der_enthalpyOfNonCondensingGas);
        end enthalpyOfNonCondensingGas;

        redeclare function extends enthalpyOfVaporization
            "Enthalpy of vaporization of water"
        algorithm
          r0 := h_fg;
          annotation (
            Inline=true);
        end enthalpyOfVaporization;

        redeclare function extends gasConstant
            "Return ideal gas constant as a function from thermodynamic state, only valid for phi<1"

        algorithm
            R_s := dryair.R*(1 - state.X[Water]) + steam.R*state.X[Water];
          annotation (
            smoothOrder=2,
            Inline=true,
            Documentation(info="<html>
The ideal gas constant for moist air is computed from <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state</a> assuming that all water is in the gas phase.
</html>"));
        end gasConstant;

        redeclare function extends pressure
            "Returns pressure of ideal gas as a function of the thermodynamic state record"

        algorithm
          p := state.p;
          annotation (
          smoothOrder=2,
          Inline=true,
          Documentation(info="<html>
Pressure is returned from the thermodynamic state record input as a simple assignment.
</html>"));
        end pressure;

        redeclare function extends isobaricExpansionCoefficient
            "Isobaric expansion coefficient beta"
        algorithm
          beta := 0;
          annotation (
            smoothOrder=5,
            Inline=true,
        Documentation(info="<html>
<p>
This function returns the isobaric expansion coefficient at constant pressure,
which is zero for this medium.
The isobaric expansion coefficient at constant pressure is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&beta;<sub>p</sub> = - 1 &frasl; v &nbsp; (&part; v &frasl; &part; T)<sub>p</sub> = 0,
</p>
<p>
where
<i>v</i> is the specific volume,
<i>T</i> is the temperature and
<i>p</i> is the pressure.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isobaricExpansionCoefficient;

        redeclare function extends isothermalCompressibility
            "Isothermal compressibility factor"
        algorithm
          kappa := -1/state.p;
          annotation (
            smoothOrder=5,
            Inline=true,
            Documentation(info="<html>
<p>
This function returns the isothermal compressibility coefficient.
The isothermal compressibility is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&kappa;<sub>T</sub> = -1 &frasl; v &nbsp; (&part; v &frasl; &part; p)<sub>T</sub>
  = -1 &frasl; p,
</p>
<p>
where
<i>v</i> is the specific volume,
<i>T</i> is the temperature and
<i>p</i> is the pressure.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isothermalCompressibility;

        redeclare function extends saturationPressure
            "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"

        algorithm
            psat := IBPSA.Utilities.Psychrometrics.Functions.saturationPressure(Tsat);
          annotation (
          smoothOrder=5,
          Inline=true);
        end saturationPressure;

        redeclare function extends specificEntropy
            "Return the specific entropy, only valid for phi<1"

        protected
            Modelica.Units.SI.MoleFraction[2] Y "Molar fraction";
        algorithm
            Y := massToMoleFractions(
                 state.X, {steam.MM,dryair.MM});
            s := specificHeatCapacityCp(state) * Modelica.Math.log(state.T/reference_T)
                 - Modelica.Constants.R *
                 sum(state.X[i]/MMX[i]*
                     Modelica.Math.log(max(Y[i], Modelica.Constants.eps)*state.p/reference_p) for i in 1:2);
          annotation (
          Inline=true,
            Documentation(info="<html>
<p>
This function computes the specific entropy.
</p>
<p>
The specific entropy of the mixture is obtained from
</p>
<p align=\"center\" style=\"font-style:italic;\">
s = s<sub>s</sub> + s<sub>m</sub>,
</p>
<p>
where
<i>s<sub>s</sub></i> is the entropy change due to the state change
(relative to the reference temperature) and
<i>s<sub>m</sub></i> is the entropy change due to mixing
of the dry air and water vapor.
</p>
<p>
The entropy change due to change in state is obtained from
</p>
<p align=\"center\" style=\"font-style:italic;\">
s<sub>s</sub> = c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(v/v<sub>0</sub>) <br/>
= c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(&rho;<sub>0</sub>/&rho;)
</p>
<p>If we assume <i>&rho; = p<sub>0</sub>/(R T)</i>,
and because <i>c<sub>p</sub> = c<sub>v</sub> + R</i>,
we can write
</p>
<p align=\"center\" style=\"font-style:italic;\">
s<sub>s</sub> = c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(T/T<sub>0</sub>) <br/>
=c<sub>p</sub> ln(T/T<sub>0</sub>).
</p>
<p>
Next, the entropy of mixing is obtained from a reversible isothermal
expansion process. Hence,
</p>
<p align=\"center\" style=\"font-style:italic;\">
  s<sub>m</sub> = -R &sum;<sub>i</sub>( X<sub>i</sub> &frasl; M<sub>i</sub>
  ln(Y<sub>i</sub> p/p<sub>0</sub>)),
</p>
<p>
where <i>R</i> is the gas constant,
<i>X</i> is the mass fraction,
<i>M</i> is the molar mass, and
<i>Y</i> is the mole fraction.
</p>
<p>
To obtain the state for a given pressure, entropy and mass fraction, use
<a href=\"modelica://IBPSA.Media.Air.setState_psX\">
IBPSA.Media.Air.setState_psX</a>.
</p>
<h4>Limitations</h4>
<p>
This function is only valid for a relative humidity below 100%.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 27, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end specificEntropy;

        redeclare function extends density_derp_T
            "Return the partial derivative of density with respect to pressure at constant temperature"
        algorithm
          ddpT := dStp/pStp;
          annotation (
          Inline=true,
        Documentation(info="<html>
<p>
This function returns the partial derivative of density
with respect to pressure at constant temperature.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end density_derp_T;

        redeclare function extends density_derT_p
            "Return the partial derivative of density with respect to temperature at constant pressure"
        algorithm
          ddTp := 0;

          annotation (
          smoothOrder=99,
          Inline=true,
          Documentation(info=
        "<html>
<p>
This function computes the derivative of density with respect to temperature
at constant pressure.
</p>
</html>",         revisions=
        "<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end density_derT_p;

        redeclare function extends density_derX
            "Return the partial derivative of density with respect to mass fractions at constant pressure and temperature"
        algorithm
          dddX := fill(0, nX);
        annotation (
          smoothOrder=99,
          Inline=true,
          Documentation(info="<html>
<p>
This function returns the partial derivative of density
with respect to mass fraction.
This value is zero because in this medium, density is proportional
to pressure, but independent of the species concentration.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end density_derX;

        redeclare replaceable function extends specificHeatCapacityCp
            "Specific heat capacity of gas mixture at constant pressure"
        algorithm
          cp := dryair.cp*(1-state.X[Water]) +steam.cp*state.X[Water];
            annotation (
          smoothOrder=99,
          Inline=true,
          derivative=der_specificHeatCapacityCp);
        end specificHeatCapacityCp;

        redeclare replaceable function extends specificHeatCapacityCv
            "Specific heat capacity of gas mixture at constant volume"
        algorithm
          cv:= dryair.cv*(1-state.X[Water]) +steam.cv*state.X[Water];
          annotation (
            smoothOrder=99,
            Inline=true,
            derivative=der_specificHeatCapacityCv);
        end specificHeatCapacityCv;

        redeclare function setState_dTX
            "Return thermodynamic state as function of density d, temperature T and composition X"
          extends Modelica.Icons.Function;
          input Density d "Density";
          input Temperature T "Temperature";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "Thermodynamic state";

        algorithm
            // Note that d/dStp = p/pStp, hence p = d*pStp/dStp
            state := if size(X, 1) == nX then
                       ThermodynamicState(p=d*pStp/dStp, T=T, X=X)
                     else
                       ThermodynamicState(p=d*pStp/dStp,
                                          T=T,
                                          X=cat(1, X, {1 - sum(X)}));
            annotation (
            smoothOrder=2,
            Inline=true,
            Documentation(info="<html>
<p>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">thermodynamic state record</a>
    is computed from density <code>d</code>, temperature <code>T</code> and composition <code>X</code>.
</p>
</html>"));
        end setState_dTX;

        redeclare function extends setState_phX
            "Return thermodynamic state as function of pressure p, specific enthalpy h and composition X"
        algorithm
          state := if size(X, 1) == nX then
            ThermodynamicState(p=p, T=temperature_phX(p, h, X), X=X)
         else
            ThermodynamicState(p=p, T=temperature_phX(p, h, X), X=cat(1, X, {1 - sum(X)}));
          annotation (
          smoothOrder=2,
          Inline=true,
          Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">
thermodynamic state record</a> is computed from pressure p, specific enthalpy h and composition X.
</html>"));
        end setState_phX;

        redeclare function extends setState_pTX
            "Return thermodynamic state as function of p, T and composition X or Xi"
        algorithm
            state := if size(X, 1) == nX then
                        ThermodynamicState(p=p, T=T, X=X)
                     else
                        ThermodynamicState(p=p, T=T, X=cat(1, X, {1 - sum(X)}));
            annotation (
          smoothOrder=2,
          Inline=true,
          Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">
thermodynamic state record</a> is computed from pressure p, temperature T and composition X.
</html>"));
        end setState_pTX;

        redeclare function extends setState_psX
            "Return the thermodynamic state as function of p, s and composition X or Xi"
        protected
            Modelica.Units.SI.MassFraction[2] X_int "Mass fraction";
            Modelica.Units.SI.MoleFraction[2] Y "Molar fraction";
            Modelica.Units.SI.Temperature T "Temperature";
        algorithm
            if size(X, 1) == nX then
              X_int:=X;
            else
              X_int :=cat(
                1,
                X,
                {1 - sum(X)});
            end if;
           Y := massToMoleFractions(
                 X_int, {steam.MM,dryair.MM});
            // The next line is obtained from symbolic solving the
            // specificEntropy function for T.
            // In this formulation, we can set T to any value when calling
            // specificHeatCapacityCp as cp does not depend on T.
            T := 273.15 * Modelica.Math.exp((s + Modelica.Constants.R *
                   sum(X_int[i]/MMX[i]*
                     Modelica.Math.log(max(Y[i], Modelica.Constants.eps)) for i in 1:2))
                     / specificHeatCapacityCp(setState_pTX(p=p,
                                                           T=273.15,
                                                           X=X_int)));

            state := ThermodynamicState(p=p,
                                        T=T,
                                        X=X_int);

        annotation (
        Inline=true,
        Documentation(info="<html>
<p>
This function returns the thermodynamic state based on pressure,
specific entropy and mass fraction.
</p>
<p>
The state is computed by symbolically solving
<a href=\"modelica://IBPSA.Media.Air.specificEntropy\">
IBPSA.Media.Air.specificEntropy</a>
for temperature.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 27, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end setState_psX;

        redeclare replaceable function extends specificEnthalpy
            "Compute specific enthalpy from pressure, temperature and mass fraction"
        algorithm
          h := (state.T - reference_T)*dryair.cp * (1 - state.X[Water]) +
               ((state.T-reference_T) * steam.cp + h_fg) * state.X[Water];
          annotation (
           smoothOrder=5,
           Inline=true);
        end specificEnthalpy;

        redeclare replaceable function specificEnthalpy_pTX "Specific enthalpy"
          extends Modelica.Icons.Function;
            input Modelica.Units.SI.Pressure p "Pressure";
            input Modelica.Units.SI.Temperature T "Temperature";
            input Modelica.Units.SI.MassFraction X[:] "Mass fractions of moist air";
            output Modelica.Units.SI.SpecificEnthalpy h "Specific enthalpy at p, T, X";

        algorithm
          h := specificEnthalpy(setState_pTX(p, T, X));
          annotation(smoothOrder=5,
                     Inline=true,
                     inverse(T=temperature_phX(p, h, X)),
                     Documentation(info="<html>
Specific enthalpy as a function of temperature and species concentration.
The pressure is input for compatibility with the medium models, but the specific enthalpy
is independent of the pressure.
</html>",
        revisions="<html>
<ul>
<li>
April 30, 2015, by Filip Jorissen and Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
</ul>
</html>"));
        end specificEnthalpy_pTX;

        redeclare replaceable function extends specificGibbsEnergy
            "Specific Gibbs energy"
        algorithm
          g := specificEnthalpy(state) - state.T*specificEntropy(state);
          annotation (
            Inline=true);
        end specificGibbsEnergy;

        redeclare replaceable function extends specificHelmholtzEnergy
            "Specific Helmholtz energy"
        algorithm
          f := specificEnthalpy(state) - gasConstant(state)*state.T - state.T*specificEntropy(state);
          annotation (
            Inline=true);
        end specificHelmholtzEnergy;

        redeclare function extends isentropicEnthalpy "Return the isentropic enthalpy"
        algorithm
          h_is := specificEnthalpy(setState_psX(
                    p=p_downstream,
                    s=specificEntropy(refState),
                    X=refState.X));
        annotation (
          Inline=true,
          Documentation(info="<html>
<p>
This function computes the specific enthalpy for
an isentropic state change from the temperature
that corresponds to the state <code>refState</code>
to <code>reference_T</code>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isentropicEnthalpy;

        redeclare function extends specificInternalEnergy "Specific internal energy"
          extends Modelica.Icons.Function;
        algorithm
          u := specificEnthalpy(state) - pStp/dStp;
          annotation (
            Inline=true);
        end specificInternalEnergy;

        redeclare function extends temperature
            "Return temperature of ideal gas as a function of the thermodynamic state record"
        algorithm
          T := state.T;
          annotation (
          smoothOrder=2,
          Inline=true,
          Documentation(info="<html>
Temperature is returned from the thermodynamic state record input as a simple assignment.
</html>"));
        end temperature;

        redeclare function extends molarMass "Return the molar mass"
        algorithm
            MM := 1/(state.X[Water]/MMX[Water]+(1.0-state.X[Water])/MMX[Air]);
            annotation (
        Inline=true,
        smoothOrder=99,
        Documentation(info="<html>
<p>
This function returns the molar mass.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end molarMass;

        redeclare replaceable function temperature_phX
            "Compute temperature from specific enthalpy and mass fraction"
            extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "specific enthalpy";
          input MassFraction[:] X "mass fractions of composition";
          output Temperature T "temperature";
        algorithm
          T := reference_T + (h - h_fg * X[Water])
               /((1 - X[Water])*dryair.cp + X[Water] * steam.cp);
          annotation(smoothOrder=5,
                     Inline=true,
                     inverse(h=specificEnthalpy_pTX(p, T, X)),
                     Documentation(info="<html>
Temperature as a function of specific enthalpy and species concentration.
The pressure is input for compatibility with the medium models, but the temperature
is independent of the pressure.
</html>",
        revisions="<html>
<ul>
<li>
April 30, 2015, by Filip Jorissen and Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
</ul>
</html>"));
        end temperature_phX;

        redeclare function extends thermalConductivity
            "Thermal conductivity of dry air as a polynomial in the temperature"
        algorithm
          lambda :=Modelica.Math.Polynomials.evaluate({(-4.8737307422969E-008),
              7.67803133753502E-005,0.0241814385504202},
              Modelica.Units.Conversions.to_degC(state.T));
        annotation(LateInline=true);
        end thermalConductivity;
        //////////////////////////////////////////////////////////////////////
        // Protected classes.
        // These classes are only of use within this medium model.
        // Models generally have no need to access them.
        // Therefore, they are made protected. This also allows to redeclare the
        // medium model with another medium model that does not provide an
        // implementation of these classes.
      protected
          record GasProperties
            "Coefficient data record for properties of perfect gases"
            extends Modelica.Icons.Record;

            Modelica.Units.SI.MolarMass MM "Molar mass";
            Modelica.Units.SI.SpecificHeatCapacity R "Gas constant";
            Modelica.Units.SI.SpecificHeatCapacity cp
              "Specific heat capacity at constant pressure";
            Modelica.Units.SI.SpecificHeatCapacity cv=cp - R
              "Specific heat capacity at constant volume";
            annotation (
              preferredView="info",
              Documentation(info="<html>
<p>
This data record contains the coefficients for perfect gases.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 12, 2014, by Michael Wetter:<br/>
Corrected the wrong location of the <code>preferredView</code>
and the <code>revisions</code> annotation.
</li>
<li>
November 21, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end GasProperties;
          constant Modelica.Units.SI.SpecificEnergy h_fg=IBPSA.Utilities.Psychrometrics.Constants.h_fg
            "Latent heat of evaporation of water";
          constant Modelica.Units.SI.SpecificHeatCapacity cpWatLiq=IBPSA.Utilities.Psychrometrics.Constants.cpWatLiq
            "Specific heat capacity of liquid water";

        replaceable function der_enthalpyOfLiquid
            "Temperature derivative of enthalpy of liquid per unit mass of liquid"
          extends Modelica.Icons.Function;
          input Temperature T "Temperature";
          input Real der_T "Temperature derivative";
          output Real der_h "Derivative of liquid enthalpy";
        algorithm
          der_h := cpWatLiq*der_T;
          annotation (
            Inline=true);
        end der_enthalpyOfLiquid;

        function der_enthalpyOfCondensingGas
            "Derivative of enthalpy of steam per unit mass of steam"
          extends Modelica.Icons.Function;
          input Temperature T "Temperature";
          input Real der_T "Temperature derivative";
          output Real der_h "Derivative of steam enthalpy";
        algorithm
          der_h := steam.cp*der_T;
          annotation (
            Inline=true);
        end der_enthalpyOfCondensingGas;

        replaceable function enthalpyOfDryAir
            "Enthalpy of dry air per unit mass of dry air"
          extends Modelica.Icons.Function;

          input Temperature T "Temperature";
          output SpecificEnthalpy h "Dry air enthalpy";
        algorithm
          h := (T - reference_T)*dryair.cp;
          annotation (
            smoothOrder=5,
            Inline=true,
            derivative=der_enthalpyOfDryAir);
        end enthalpyOfDryAir;

        replaceable function der_enthalpyOfDryAir
            "Derivative of enthalpy of dry air per unit mass of dry air"
          extends Modelica.Icons.Function;
          input Temperature T "Temperature";
          input Real der_T "Temperature derivative";
          output Real der_h "Derivative of dry air enthalpy";
        algorithm
          der_h := dryair.cp*der_T;
          annotation (
            Inline=true);
        end der_enthalpyOfDryAir;

        replaceable function der_enthalpyOfNonCondensingGas
            "Derivative of enthalpy of non-condensing gas per unit mass of steam"
          extends Modelica.Icons.Function;
          input Temperature T "Temperature";
          input Real der_T "Temperature derivative";
          output Real der_h "Derivative of steam enthalpy";
        algorithm
          der_h := der_enthalpyOfDryAir(T, der_T);
          annotation (
            Inline=true);
        end der_enthalpyOfNonCondensingGas;

        replaceable function der_specificHeatCapacityCp
            "Derivative of specific heat capacity of gas mixture at constant pressure"
          extends Modelica.Icons.Function;
            input ThermodynamicState state "Thermodynamic state";
            input ThermodynamicState der_state "Derivative of thermodynamic state";
            output Real der_cp(unit="J/(kg.K.s)")
              "Derivative of specific heat capacity";
        algorithm
          der_cp := (steam.cp-dryair.cp)*der_state.X[Water];
          annotation (
            Inline=true);
        end der_specificHeatCapacityCp;

        replaceable function der_specificHeatCapacityCv
            "Derivative of specific heat capacity of gas mixture at constant volume"
          extends Modelica.Icons.Function;
            input ThermodynamicState state "Thermodynamic state";
            input ThermodynamicState der_state "Derivative of thermodynamic state";
            output Real der_cv(unit="J/(kg.K.s)")
              "Derivative of specific heat capacity";
        algorithm
          der_cv := (steam.cv-dryair.cv)*der_state.X[Water];
          annotation (
            Inline=true);
        end der_specificHeatCapacityCv;
          annotation(Documentation(info="<html>
<p>
This medium package models moist air using a gas law in which pressure and temperature
are independent, which often leads to significantly faster and more robust computations.
The specific heat capacities at constant pressure and at constant volume are constant.
The air is assumed to be not saturated.
</p>
<p>
This medium uses the gas law
</p>
<p align=\"center\" style=\"font-style:italic;\">
&rho;/&rho;<sub>stp</sub> = p/p<sub>stp</sub>,
</p>
<p>
where
<i>p<sub>std</sub></i> and <i>&rho;<sub>stp</sub></i> are constant reference
temperature and density, rathern than the ideal gas law
</p>
<p align=\"center\" style=\"font-style:italic;\">
&rho; = p &frasl;(R T),
</p>
<p>
where <i>R</i> is the gas constant and <i>T</i> is the temperature.
</p>
<p>
This formulation often leads to smaller systems of nonlinear equations
because equations for pressure and temperature are decoupled.
Therefore, if air inside a control volume such as room air is heated, it
does not increase its specific volume. Consequently, merely heating or cooling
a control volume does not affect the air flow calculations in a duct network
that may be connected to that volume.
Note that multizone air exchange simulation in which buoyancy drives the
air flow is still possible as the models in
<a href=\"modelica://IBPSA.Airflow.Multizone\">
IBPSA.Airflow.Multizone</a> compute the mass density using the function
<a href=\"modelica://IBPSA.Utilities.Psychrometrics.Functions.density_pTX\">
IBPSA.Utilities.Psychrometrics.Functions.density_pTX</a> in which density
is a function of temperature.
</p>
<p>
Note that models in this package implement the equation for the internal energy as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p<sub>stp</sub> &frasl; &rho;<sub>stp</sub>,
</p>
<p>
where
<i>u</i> is the internal energy per unit mass,
<i>h</i> is the enthalpy per unit mass,
<i>p<sub>stp</sub></i> is the static pressure and
<i>&rho;<sub>stp</sub></i> is the mass density at standard pressure and temperature.
The reason for this implementation is that in general,
</p>
<p align=\"center\" style=\"font-style:italic;\">
  h = u + p v,
</p>
<p>
from which follows that
</p>
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p v = h - p &frasl; &rho; = h - p<sub>stp</sub> &frasl; &rho;<sub>std</sub>,
</p>
<p>
because <i>p &frasl; &rho; = p<sub>stp</sub> &frasl; &rho;<sub>stp</sub></i> in this medium model.
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C and no water vapor is present.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 9, 2022, by Michael Wetter:<br/>
Set nominal attribute for <code>BaseProperties.Xi</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1634\">#1634</a>.
</li>
<li>
September 28, 2020, by Michael Wetter:<br/>
Reformulated <code>BaseProperties</code> to avoid event-triggering assertions.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1401\">#1401</a>.
</li>
<li>
January 11, 2019 by Michael Wetter:<br/>
Reforulated assignment of <code>X_int</code> in <code>setState_psX</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1079\">#1079</a>.
</li>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
November 4, 2016, by Michael Wetter:<br/>
Set default value for <code>dT.start</code> in base properties.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/575\">#575</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Set <code>AbsolutePressure(start=p_default)</code> to avoid
a translation error if
<a href=\"modelica://IBPSA.Fluid.Sources.Examples.TraceSubstancesFlowSource\">
IBPSA.Fluid.Sources.Examples.TraceSubstancesFlowSource</a>
is translated in pedantic mode in Dymola 2016.
The reason is that pressures use <code>Medium.p_default</code> as start values,
but
<a href=\"modelica://Modelica.Media.Interfaces.Types\">
Modelica.Media.Interfaces.Types</a>
sets a default value of <i>1E-5</i>.
A similar change has been done for pressure.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Added <code>stateSelect</code> attribute in <code>BaseProperties.T</code>
to allow correct use of <code>preferredMediumState</code> as
described in
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">
Modelica.Media.Interfaces.PartialMedium</a>.
Note that the default is <code>preferredMediumState=false</code>
and hence the same states are used as were used before.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
May 11, 2015, by Michael Wetter:<br/>
Removed
<code>p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)</code>
in declaration of <code>BaseProperties</code>.
Otherwise, when models that contain a fluid volume
are exported as an FMU, their pressure would be
differentiated with respect to time. This would require
the time derivative of the inlet pressure, which is not available,
causing the translation to stop with an error.
</li>
<li>
May 1, 2015, by Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
<li>
March 20, 2015, by Michael Wetter:<br/>
Added missing term <code>state.p/reference_p</code> in function
<code>specificEntropy</code>.
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/193\">#193</a>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
July 24, 2014, by Michael Wetter:<br/>
Changed implementation to use
<a href=\"modelica://IBPSA.Utilities.Psychrometrics.Constants\">
IBPSA.Utilities.Psychrometrics.Constants</a>.
This was done to use consistent values throughout the library.
</li>
<li>
November 16, 2013, by Michael Wetter:<br/>
Revised and simplified the implementation.
</li>
<li>
November 14, 2013, by Michael Wetter:<br/>
Removed function
<code>HeatCapacityOfWater</code>
which is neither needed nor implemented in the
Modelica Standard Library.
</li>
<li>
November 13, 2013, by Michael Wetter:<br/>
Removed non-used computations in <code>specificEnthalpy_pTX</code> and
in <code>temperature_phX</code>.
</li>
<li>
March 29, 2013, by Michael Wetter:<br/>
Added <code>final standardOrderComponents=true</code> in the
<code>BaseProperties</code> declaration. This avoids an error
when models are checked in Dymola 2014 in the pedenatic mode.
</li>
<li>
April 12, 2012, by Michael Wetter:<br/>
Added keyword <code>each</code> to <code>Xi(stateSelect=...)</code>.
</li>
<li>
April 4, 2012, by Michael Wetter:<br/>
Added redeclaration of <code>ThermodynamicState</code> to avoid a warning
during model check and translation.
</li>
<li>
August 3, 2011, by Michael Wetter:<br/>
Fixed bug in <code>u=h-R*T</code>, which is only valid for ideal gases.
For this medium, the function is <code>u=h-pStd/dStp</code>.
</li>
<li>
January 27, 2010, by Michael Wetter:<br/>
Fixed bug in <code>else</code> branch of function <code>setState_phX</code>
that lead to a run-time error when the constructor of this function was called.
</li>
<li>
January 22, 2010, by Michael Wetter:<br/>
Added implementation of function
<a href=\"modelica://IBPSA.Media.GasesPTDecoupled.MoistAirUnsaturated.enthalpyOfNonCondensingGas\">
enthalpyOfNonCondensingGas</a> and its derivative.
</li>
<li>
January 13, 2010, by Michael Wetter:<br/>
Fixed implementation of derivative functions.
</li>
<li>
August 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
                Ellipse(
                  extent={{-78,78},{-34,34}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={120,120,120}),
                Ellipse(
                  extent={{-18,86},{26,42}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={120,120,120}),
                Ellipse(
                  extent={{48,58},{92,14}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={120,120,120}),
                Ellipse(
                  extent={{-22,32},{22,-12}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={120,120,120}),
                Ellipse(
                  extent={{36,-32},{80,-76}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={120,120,120}),
                Ellipse(
                  extent={{-36,-30},{8,-74}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={120,120,120}),
                Ellipse(
                  extent={{-90,-6},{-46,-50}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={120,120,120})}));
        end Air;

        package Water "Package with model for liquid water with constant density"
           extends Modelica.Media.Water.ConstantPropertyLiquidWater(
             p_default=300000,
             reference_p=300000,
             reference_T=273.15,
             reference_X={1},
             AbsolutePressure(start=p_default),
             Temperature(start=T_default),
             Density(start=d_const),
             final cv_const=cp_const);
          // cp_const and cv_const have been made final because the model sets u=h.
          extends Modelica.Icons.Package;

          redeclare replaceable model BaseProperties "Base properties (p, d, T, h, u, R, MM and X and Xi) of a medium"
            parameter Boolean preferredMediumStates=false
              "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
              annotation (Evaluate=true, Dialog(tab="Advanced"));
            final parameter Boolean standardOrderComponents=true
              "If true, and reducedX = true, the last element of X will be computed from the other ones";
            Modelica.Units.SI.Density d=d_const "Density of medium";
            Temperature T(stateSelect=
              if preferredMediumStates then StateSelect.prefer else StateSelect.default)
              "Temperature of medium";
            InputAbsolutePressure p "Absolute pressure of medium";
            InputMassFraction[nXi] Xi=fill(0, 0)
              "Structurally independent mass fractions";
            InputSpecificEnthalpy h "Specific enthalpy of medium";
            Modelica.Units.SI.SpecificInternalEnergy u
              "Specific internal energy of medium";

            Modelica.Units.SI.MassFraction[nX] X={1}
              "Mass fractions (= (component mass)/total mass  m_i/m)";
            final Modelica.Units.SI.SpecificHeatCapacity R_s=0
              "Gas constant (of mixture if applicable)";
            final Modelica.Units.SI.MolarMass MM=MM_const
              "Molar mass (of mixture or single fluid)";
            ThermodynamicState state
              "Thermodynamic state record for optional functions";

            Modelica.Units.NonSI.Temperature_degC T_degC=
                Modelica.Units.Conversions.to_degC(T) "Temperature of medium in [degC]";
            Modelica.Units.NonSI.Pressure_bar p_bar=Modelica.Units.Conversions.to_bar(p)
              "Absolute pressure of medium in [bar]";

            // Local connector definition, used for equation balancing check
            connector InputAbsolutePressure = input Modelica.Units.SI.AbsolutePressure
              "Pressure as input signal connector";
            connector InputSpecificEnthalpy = input Modelica.Units.SI.SpecificEnthalpy
              "Specific enthalpy as input signal connector";
            connector InputMassFraction = input Modelica.Units.SI.MassFraction
              "Mass fraction as input signal connector";

          equation
            h = cp_const*(T-reference_T);
            u = h;
            state.T = T;
            state.p = p;

            // Assertions to test for bounds
            assert(noEvent(T >= T_min), "In " + getInstanceName() + ": Temperature T = " + String(T) + " K exceeded its minimum allowed value of " +
          String(T_min-273.15) + " degC (" + String(T_min) + " Kelvin) as required from medium model \"IBPSA.Media.Water\".");

            assert(noEvent(T <= T_max), "In " + getInstanceName() + ": Temperature T = " + String(T) + " K exceeded its maximum allowed value of " +
          String(T_max-273.15) + " degC (" + String(T_max) + " Kelvin) as required from medium model \"IBPSA.Media.Water\".");

            assert(noEvent(p >= 0.0), "Pressure (= " + String(p) + " Pa) of medium \"IBPSA.Media.Water\" is negative\n(Temperature = " + String(T) + " K)");

            annotation(Documentation(info="<html>
<p>
Model with basic thermodynamic properties.
</p>
<p>
This base properties model is identical to
<a href=\"modelica://Modelica.Media.Water.ConstantPropertyLiquidWater\">
Modelica.Media.Water.ConstantPropertyLiquidWater</a>,
except that the equation
<code>u = cv_const*(T - reference_T)</code>
has been replaced by <code>u=h</code> because
<code>cp_const=cv_const</code>.
</p>
<p>
This model provides equation for the following thermodynamic properties:
</p>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\" summary=\"Thermodynamic properties\">
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>absolute pressure</td></tr>
  <tr><td>d</td>
      <td>kg/m3</td>
      <td>density</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>Xi[nXi]</td>
      <td>kg/kg</td>
      <td>independent mass fractions m_i/m</td></tr>
  <tr><td>R</td>
      <td>J/kg.K</td>
      <td>gas constant</td></tr>
  <tr><td>M</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
</html>"));
          end BaseProperties;

        function enthalpyOfLiquid "Return the specific enthalpy of liquid"
          extends Modelica.Icons.Function;
            input Modelica.Units.SI.Temperature T "Temperature";
            output Modelica.Units.SI.SpecificEnthalpy h "Specific enthalpy";
        algorithm
          h := cp_const*(T-reference_T);
        annotation (
          smoothOrder=5,
          Inline=true,
        Documentation(info="<html>
<p>
Enthalpy of the water.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 16, 2014 by Michael Wetter:<br/>
First implementation.
This function is used by
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.MixingVolumeMoistAir\">
IBPSA.Fluid.MixingVolumes.MixingVolumeMoistAir</a>.
</li>
</ul>
</html>"));
        end enthalpyOfLiquid;
          annotation(Documentation(info="<html>
<p>
This medium package models liquid water.
</p>
<p>
The mass density is computed using a constant value of <i>995.586</i> kg/s.
For a medium model in which the density is a function of temperature, use
<a href=\"modelica://IBPSA.Media.Specialized.Water.TemperatureDependentDensity\">
IBPSA.Media.Specialized.Water.TemperatureDependentDensity</a> which may have considerably higher computing time.
</p>
<p>
For the specific heat capacities at constant pressure and at constant volume,
a constant value of <i>4184</i> J/(kg K), which corresponds to <i>20</i>&deg;C
is used.
The figure below shows the relative error of the specific heat capacity that
is introduced by this simplification.
</p>
<p align=\"center\">
<img src=\"modelica://IBPSA/Resources/Images/Media/Water/plotCp.png\" border=\"1\"
alt=\"Relative variation of specific heat capacity with temperature\"/>
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C.
</p>
<h4>Limitations</h4>
<p>
Density, specific heat capacity, thermal conductivity and viscosity are constant.
Water is modeled as an incompressible liquid.
There are no phase changes.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2020, by Michael Wetter:<br/>
Reformulated <code>BaseProperties</code> to avoid event-triggering assertions.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1401\">#1401</a>.
</li>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Set <code>AbsolutePressure(start=p_default)</code> to avoid
a translation error if
<a href=\"modelica://IBPSA.Fluid.Sources.Examples.TraceSubstancesFlowSource\">
IBPSA.Fluid.Sources.Examples.TraceSubstancesFlowSource</a>
(if used with water instead of air)
is translated in pedantic mode in Dymola 2016.
The reason is that pressures use <code>Medium.p_default</code> as start values,
but
<a href=\"modelica://Modelica.Media.Interfaces.Types\">
Modelica.Media.Interfaces.Types</a>
sets a default value of <i>1E-5</i>.
A similar change has been done for pressure and density.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Changed type of <code>BaseProperties.T</code> from
<code>Modelica.Units.SI.Temperature</code> to <code>Temperature</code>.
Otherwise, it has a different start value than <code>Medium.T</code>, which
causes an error if
<a href=\"modelica://IBPSA.Media.Examples.WaterProperties\">
IBPSA.Media.Examples.WaterProperties</a>
is translated in pedantic mode.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Added <code>stateSelect</code> attribute in <code>BaseProperties.T</code>
to allow correct use of <code>preferredMediumState</code> as
described in
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">
Modelica.Media.Interfaces.PartialMedium</a>,
and set <code>preferredMediumState=false</code>
to keep the same states as were used before.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Removed <code>ThermodynamicState</code> declaration as this lead to
the error
\"Attempting to redeclare record ThermodynamicState when the original was not replaceable.\"
in Dymola 2016 using the pedantic model check.
</li>
<li>
May 1, 2015, by Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
<li>
February 25, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect</code> attribute on pressure as this caused
<a href=\"modelica://IBPSA.Examples.Tutorial.SpaceCooling.System3\">
IBPSA.Examples.Tutorial.SpaceCooling.System3</a>
to fail with the error message
\"differentiated if-then-else was not continuous\".
</li>
<li>
October 15, 2014, by Michael Wetter:<br/>
Reimplemented media based on
<a href=\"https://github.com/ibpsa/modelica-ibpsa/blob/446aa83720884052476ad6d6d4f90a6a29bb8ec9/IBPSA/Media/Water.mo\">446aa83</a>.
</li>
<li>
November 15, 2013, by Michael Wetter:<br/>
Complete new reimplementation because the previous version
had the option to add a compressibility to the medium, which
has never been used.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                graphics={
                Polygon(
                  points={{16,-28},{32,-42},{26,-48},{10,-36},{16,-28}},
                  lineColor={95,95,95},
                  fillPattern=FillPattern.Sphere,
                  fillColor={95,95,95}),
                Polygon(
                  points={{10,34},{26,44},{30,36},{14,26},{10,34}},
                  lineColor={95,95,95},
                  fillPattern=FillPattern.Sphere,
                  fillColor={95,95,95}),
                Ellipse(
                  extent={{-82,52},{24,-54}},
                  lineColor={95,95,95},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,0,0}),
                Ellipse(
                  extent={{22,82},{80,24}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={95,95,95}),
                Ellipse(
                  extent={{20,-30},{78,-88}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={95,95,95})}));
        end Water;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains media models for water and moist air.
The media models in this package are
compatible with
<a href=\"modelica://Modelica.Media\">
Modelica.Media</a>
but the implementation is in general simpler, which often
leads to more efficient simulation.
Due to the simplifications, the media model of this package
are generally accurate for a smaller temperature range than the
models in <a href=\"modelica://Modelica.Media\">
Modelica.Media</a>, but the smaller temperature range may often be
sufficient for building HVAC applications.
</p>
</html>"),
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Line(
                points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
                color={64,64,64},
                smooth=Smooth.Bezier),
              Line(
                points={{-40,20},{68,20}},
                color={175,175,175}),
              Line(
                points={{-40,20},{-44,88},{-44,88}},
                color={175,175,175}),
              Line(
                points={{68,20},{86,-58}},
                color={175,175,175}),
              Line(
                points={{-60,-28},{56,-28}},
                color={175,175,175}),
              Line(
                points={{-60,-28},{-74,84},{-74,84}},
                color={175,175,175}),
              Line(
                points={{56,-28},{70,-80}},
                color={175,175,175}),
              Line(
                points={{-76,-80},{38,-80}},
                color={175,175,175}),
              Line(
                points={{-76,-80},{-94,-16},{-94,-16}},
                color={175,175,175})}));
      end Media;

      package Utilities "Package with utility functions such as for I/O"
        extends Modelica.Icons.Package;

        package Math "Library with functions such as for smoothing"
          extends Modelica.Icons.Package;

          package Functions "Package with mathematical functions"
            extends Modelica.Icons.VariantsPackage;

            function inverseXRegularized
              "Function that approximates 1/x by a twice continuously differentiable function"
              extends Modelica.Icons.Function;
             input Real x "Abscissa value";
             input Real delta(min=Modelica.Constants.eps)
                "Abscissa value below which approximation occurs";
             input Real deltaInv = 1/delta "Inverse value of delta";

             input Real a = -15*deltaInv "Polynomial coefficient";
             input Real b = 119*deltaInv^2 "Polynomial coefficient";
             input Real c = -361*deltaInv^3 "Polynomial coefficient";
             input Real d = 534*deltaInv^4 "Polynomial coefficient";
             input Real e = -380*deltaInv^5 "Polynomial coefficient";
             input Real f = 104*deltaInv^6 "Polynomial coefficient";

             output Real y "Function value";

            algorithm
              y := if (x > delta or x < -delta) then 1/x elseif (x < delta/2 and x > -delta/2) then x/(delta*delta) else IBPSA.Utilities.Math.Functions.BaseClasses.smoothTransition(
                x=x,
                delta=delta,
                deltaInv=deltaInv,
                a=a,
                b=b,
                c=c,
                d=d,
                e=e,
                f=f);

              annotation (smoothOrder=2,
              derivative(order=1,
                      zeroDerivative=delta,
                      zeroDerivative=deltaInv,
                      zeroDerivative=a,
                      zeroDerivative=b,
                      zeroDerivative=c,
                      zeroDerivative=d,
                      zeroDerivative=e,
                      zeroDerivative=f)=IBPSA.Utilities.Math.Functions.BaseClasses.der_inverseXRegularized,
                          Inline=true,
            Documentation(info="<html>
<p>
Function that approximates <i>y=1 &frasl; x</i>
inside the interval <i>-&delta; &le; x &le; &delta;</i>.
The approximation is twice continuously differentiable with a bounded derivative on the whole
real line.
</p>
<p>
See the plot of
<a href=\"modelica://IBPSA.Utilities.Math.Functions.Examples.InverseXRegularized\">
IBPSA.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for the graph.
</p>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Typically, these coefficients only depend on parameters and hence
can be computed once.
They must be equal to their default values, otherwise the function
is not twice continuously differentiable.
By exposing these coefficients as function arguments, models
that call this function can compute them as parameters, and
assign these parameter values in the function call.
This avoids that the coefficients are evaluated for each time step,
as they would otherwise be if they were to be computed inside the
body of the function. However, assigning the values is optional
as otherwise, at the expense of efficiency, the values will be
computed each time the function is invoked.
See
<a href=\"modelica://IBPSA.Utilities.Math.Functions.Examples.InverseXRegularized\">
IBPSA.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for how to efficiently call this function.
</p>
</html>",             revisions="<html>
<ul>
<li>
August 10, 2015, by Michael Wetter:<br/>
Removed dublicate entry <code>smoothOrder = 1</code>
and reimplmented the function so it is twice continuously differentiable.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 18, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end inverseXRegularized;

            function regStep
              "Approximation of a general step, such that the approximation is continuous and differentiable"
              extends Modelica.Icons.Function;
              input Real x "Abscissa value";
              input Real y1 "Ordinate value for x > 0";
              input Real y2 "Ordinate value for x < 0";
              input Real x_small(min=0) = 1e-5
                "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
              output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
            algorithm
              y := smooth(1, if x >  x_small then y1 else
                             if x < -x_small then y2 else
                             if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);

              annotation(Inline=true,
              Documentation(revisions="<html>
<ul>
<li><i>February 18, 2016</i>
    by Marcus Fuchs:<br/>
    Add function with <code>Inline = true</code> in annotations to package for better performance,
    as suggested in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a> .</li>
<li><i>August 12, 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
<li><i>April 29, 2008</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br/>
    Designed and implemented.</li>
</ul>
</html>",             info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <b>if</b> x &gt; 0 <b>then</b> y1 <b>else</b> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <b>smooth</b>(1, <b>if</b> x &gt;  x_small <b>then</b> y1 <b>else</b>
                 <b>if</b> x &lt; -x_small <b>then</b> y2 <b>else</b> f(y1, y2));
</pre>

<p>
In the region <code>-x_small &lt; x &lt; x_small</code> a 2nd order polynomial is used
for a smooth transition from <code>y1</code> to <code>y2</code>.
</p>
</html>"));
            end regStep;

            package BaseClasses "Package with base classes for IBPSA.Utilities.Math.Functions"
              extends Modelica.Icons.BasesPackage;

              function der_2_smoothTransition
                "Second order derivative of smoothTransition with respect to x"
                extends Modelica.Icons.Function;
                input Real x "Abscissa value";
                input Real delta(min=Modelica.Constants.eps)
                  "Abscissa value below which approximation occurs";

                input Real deltaInv "Inverse value of delta";
                input Real a "Polynomial coefficient";
                input Real b "Polynomial coefficient";
                input Real c "Polynomial coefficient";
                input Real d "Polynomial coefficient";
                input Real e "Polynomial coefficient";
                input Real f "Polynomial coefficient";

                input Real x_der "Derivative of x";
                input Real x_der2 "Second order derivative of x";
                output Real y_der2 "Second order derivative of function value";
            protected
                Real aX "Absolute value of x";
                Real ex "Intermediate expression";
              algorithm
               aX:= abs(x);
               ex     := 2*c + aX*(6*d + aX*(12*e + aX*20*f));
               y_der2 := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der2
                       + x_der*x_der*( if x > 0 then ex else -ex);

              annotation (
              Documentation(info="<html>
<p>
This function is the 2nd order derivative of
<a href=\"modelica://IBPSA.Utilities.Math.Functions.BaseClasses.smoothTransition\">
IBPSA.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
</p>
</html>",               revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
              end der_2_smoothTransition;

              function der_inverseXRegularized "Derivative of inverseXRegularised function"
                extends Modelica.Icons.Function;
               input Real x "Abscissa value";
               input Real delta(min=Modelica.Constants.eps)
                  "Abscissa value below which approximation occurs";
               input Real deltaInv = 1/delta "Inverse value of delta";

               input Real a = -15*deltaInv "Polynomial coefficient";
               input Real b = 119*deltaInv^2 "Polynomial coefficient";
               input Real c = -361*deltaInv^3 "Polynomial coefficient";
               input Real d = 534*deltaInv^4 "Polynomial coefficient";
               input Real e = -380*deltaInv^5 "Polynomial coefficient";
               input Real f = 104*deltaInv^6 "Polynomial coefficient";

               input Real x_der "Abscissa value";
               output Real y_der "Function value";

              algorithm
                y_der := if (x > delta or x < -delta) then -x_der/x/x elseif (x < delta/2 and x > -delta/2) then x_der/(delta*delta) else IBPSA.Utilities.Math.Functions.BaseClasses.der_smoothTransition(
                  x=x,
                  x_der=x_der,
                  delta=delta,
                  deltaInv=deltaInv,
                  a=a,
                  b=b,
                  c=c,
                  d=d,
                  e=e,
                  f=f);
              annotation (
              Documentation(
              info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://IBPSA.Utilities.Math.Functions.inverseXRegularized\">
IBPSA.Utilities.Math.Functions.inverseXRegularized</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
June 22, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
              end der_inverseXRegularized;

              function der_smoothTransition
                "First order derivative of smoothTransition with respect to x"
                extends Modelica.Icons.Function;
                input Real x "Abscissa value";
                input Real delta(min=Modelica.Constants.eps)
                  "Abscissa value below which approximation occurs";

                input Real deltaInv "Inverse value of delta";
                input Real a "Polynomial coefficient";
                input Real b "Polynomial coefficient";
                input Real c "Polynomial coefficient";
                input Real d "Polynomial coefficient";
                input Real e "Polynomial coefficient";
                input Real f "Polynomial coefficient";

                input Real x_der "Derivative of x";
                output Real y_der "Derivative of function value";

            protected
                Real aX "Absolute value of x";
              algorithm
               aX:= abs(x);
               y_der := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der;
               annotation(smoothOrder=1,
                        derivative(order=2,
                        zeroDerivative=delta,
                        zeroDerivative=deltaInv,
                        zeroDerivative=a,
                        zeroDerivative=b,
                        zeroDerivative=c,
                        zeroDerivative=d,
                        zeroDerivative=e,
                        zeroDerivative=f)=IBPSA.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition,
              Documentation(info="<html>
<p>
This function is the 1st order derivative of
<a href=\"modelica://IBPSA.Utilities.Math.Functions.BaseClasses.smoothTransition\">
IBPSA.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
its derivative is provided in
<a href=\"modelica://IBPSA.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
IBPSA.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
              end der_smoothTransition;

              function smoothTransition
                "Twice continuously differentiable transition between the regions"
                extends Modelica.Icons.Function;

                // The function that transitions between the regions is implemented
                // using its own function. This allows Dymola 2016 to inline the function
                // inverseXRegularized.

              input Real x "Abscissa value";
              input Real delta(min=Modelica.Constants.eps)
                  "Abscissa value below which approximation occurs";
              input Real deltaInv = 1/delta "Inverse value of delta";

              input Real a = -15*deltaInv "Polynomial coefficient";
              input Real b = 119*deltaInv^2 "Polynomial coefficient";
              input Real c = -361*deltaInv^3 "Polynomial coefficient";
              input Real d = 534*deltaInv^4 "Polynomial coefficient";
              input Real e = -380*deltaInv^5 "Polynomial coefficient";
              input Real f = 104*deltaInv^6 "Polynomial coefficient";
              output Real y "Function value";
            protected
                Real aX "Absolute value of x";

              algorithm
               aX:= abs(x);
               y := (if x >= 0 then 1 else -1) * (a + aX*(b + aX*(c + aX*(d + aX*(e + aX*f)))));
              annotation(smoothOrder=2,
                derivative(order=1,
                        zeroDerivative=delta,
                        zeroDerivative=deltaInv,
                        zeroDerivative=a,
                        zeroDerivative=b,
                        zeroDerivative=c,
                        zeroDerivative=d,
                        zeroDerivative=e,
                        zeroDerivative=f)=IBPSA.Utilities.Math.Functions.BaseClasses.der_smoothTransition,
                  Documentation(info="<html>
<p>
This function is used by
<a href=\"modelica://IBPSA.Utilities.Math.Functions.inverseXRegularized\">
IBPSA.Utilities.Math.Functions.inverseXRegularized</a>
to provide a twice continuously differentiable transition between
the different regions.
The code has been implemented in a function as this allows
to implement the function
<a href=\"modelica://IBPSA.Utilities.Math.Functions.inverseXRegularized\">
IBPSA.Utilities.Math.Functions.inverseXRegularized</a>
in such a way that Dymola inlines it.
However, this function will not be inlined as its body is too large.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
derivatives are provided in
<a href=\"modelica://IBPSA.Utilities.Math.Functions.BaseClasses.der_smoothTransition\">
IBPSA.Utilities.Math.Functions.BaseClasses.der_smoothTransition</a>
and in
<a href=\"modelica://IBPSA.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
IBPSA.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
September 12, 2018, by David Blum:<br/>
Change if-statement to if-expression.  
For issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1019\">#1019</a>.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
              end smoothTransition;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Utilities.Math.Functions\">IBPSA.Utilities.Math.Functions</a>.
</p>
</html>"));
            end BaseClasses;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for commonly used
mathematical operations. The functions are used in
the blocks
<a href=\"modelica://IBPSA.Utilities.Math\">
IBPSA.Utilities.Math</a>.
</p>
</html>"));
          end Functions;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for commonly used
mathematical operations.
The classes in this package augment the classes
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</p>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
                    {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
                    -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
                    -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
                    {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
                    0,0,0}, smooth=Smooth.Bezier)}));
        end Math;

        package Psychrometrics "Library with psychrometric functions"
          extends Modelica.Icons.VariantsPackage;

          package Constants "Library of constants for psychometric functions"
            extends Modelica.Icons.Package;

            constant Modelica.Units.SI.SpecificHeatCapacity cpAir=1006
              "Specific heat capacity of air";

            constant Modelica.Units.SI.SpecificHeatCapacity cpSte=1860
              "Specific heat capacity of water vapor";

            constant Modelica.Units.SI.SpecificHeatCapacity cpWatLiq=4184
              "Specific heat capacity of liquid water";

            constant Modelica.Units.SI.SpecificEnthalpy h_fg=2501014.5
              "Enthalpy of evaporation of water at the reference temperature";
            annotation (
              Documentation(info="<html>
<p>
This package provides constants for functions used
in the calculation of thermodynamic properties of moist air.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Added reference temperature.
</li>
<li>
July 24, 2014, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
                Polygon(
                  origin={-9.2597,25.6673},
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
                  smooth=Smooth.Bezier),
                Polygon(
                  origin={-19.9923,-8.3993},
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
                  smooth=Smooth.Bezier),
                Polygon(
                  origin={23.753,-11.5422},
                  fillColor={102,102,102},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.Solid,
                  points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
                  smooth=Smooth.Bezier)}));
          end Constants;

          package Functions "Package with psychrometric functions"
            extends Modelica.Icons.Package;

            function saturationPressure
              "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"
              extends Modelica.Icons.Function;
              input Modelica.Units.SI.Temperature TSat(displayUnit="degC", nominal=300)
                "Saturation temperature";
              output Modelica.Units.SI.AbsolutePressure pSat(displayUnit="Pa", nominal=1000)
                "Saturation pressure";

            algorithm
              pSat := IBPSA.Utilities.Math.Functions.regStep(
                y1=IBPSA.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TSat),
                y2=IBPSA.Utilities.Psychrometrics.Functions.sublimationPressureIce(TSat),
                x=TSat - 273.16,
                x_small=1.0);
              annotation(Inline=true,
                smoothOrder=1,
                Documentation(info="<html>
<p>
Saturation pressure of water, computed from temperature,
according to Wagner <i>et al.</i> (1993).
The range of validity is between
<i>190</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
August 19, 2015 by Michael Wetter:<br/>
Changed <code>smoothOrder</code> from <i>5</i> to <i>1</i> as
<a href=\"modelica://IBPSA.Utilities.Math.Functions.spliceFunction\">
IBPSA.Utilities.Math.Functions.spliceFunction</a> is only once
continuously differentiable.
Inlined the function.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IBPSA.Media</code>.
</li>
</ul>
</html>"));
            end saturationPressure;

            function saturationPressureLiquid
              "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 373.16 K"
              extends Modelica.Icons.Function;
              input Modelica.Units.SI.Temperature TSat(displayUnit="degC", nominal=300)
                "Saturation temperature";
              output Modelica.Units.SI.AbsolutePressure pSat(displayUnit="Pa", nominal=1000)
                "Saturation pressure";
            algorithm
              pSat := 611.657*Modelica.Math.exp(17.2799 - 4102.99/(TSat - 35.719));

              annotation (
                smoothOrder=99,
                derivative=IBPSA.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid,
                Inline=true,
                Documentation(info="<html>
<p>
Saturation pressure of water above the triple point temperature computed from temperature
according to Wagner <i>et al.</i> (1993). The range of validity is between
<i>273.16</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IBPSA.Media</code>.
</li>
</ul>
</html>"));
            end saturationPressureLiquid;

            function sublimationPressureIce
              "Return sublimation pressure of water as a function of temperature T between 190 and 273.16 K"
              extends Modelica.Icons.Function;
              input Modelica.Units.SI.Temperature TSat(displayUnit="degC", nominal=300)
                "Saturation temperature";
              output Modelica.Units.SI.AbsolutePressure pSat(displayUnit="Pa", nominal=1000)
                "Saturation pressure";
          protected
              Modelica.Units.SI.Temperature TTriple=273.16 "Triple point temperature";
              Modelica.Units.SI.AbsolutePressure pTriple=611.657 "Triple point pressure";
              Real r1=TSat/TTriple "Common subexpression";
              Real a[2]={-13.9281690,34.7078238} "Coefficients a[:]";
              Real n[2]={-1.5,-1.25} "Coefficients n[:]";
            algorithm
              pSat := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*pTriple;
              annotation (
                Inline=false,
                smoothOrder=5,
                derivative=IBPSA.Utilities.Psychrometrics.Functions.BaseClasses.der_sublimationPressureIce,
                Documentation(info="<html>
<p>
Sublimation pressure of water below the triple point temperature, computed from temperature,
according to Wagner <i>et al.</i> (1993).
The range of validity is between
<i>190</i> and <i>273.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IBPSA.Media</code>.
</li>
</ul>
</html>"));
            end sublimationPressureIce;

            package BaseClasses "Package with base classes for IBPSA.Utilities.Psychrometrics.Functions"
              extends Modelica.Icons.BasesPackage;

              function der_saturationPressureLiquid
                "Derivative of the function saturationPressureLiquid"
                extends Modelica.Icons.Function;
                input Modelica.Units.SI.Temperature TSat "Saturation temperature";
                input Real dTSat(unit="K/s") "Saturation temperature derivative";
                output Real psat_der(unit="Pa/s") "Differential of saturation pressure";

              algorithm
                psat_der:=611.657*Modelica.Math.exp(17.2799 - 4102.99
                          /(TSat - 35.719))*4102.99*dTSat/(TSat - 35.719)^2;

                annotation(Inline=false,
                  smoothOrder=98,
                  Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://IBPSA.Utilities.Psychrometrics.Functions.saturationPressureLiquid\">
IBPSA.Utilities.Psychrometrics.Functions.saturationPressureLiquid</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 12, 2020, by Michael Wetter:<br/>
Corrected name of argument to comply with derivative specification.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1393\">#1393</a>.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IBPSA.Media</code>.
</li>
</ul>
</html>"));
              end der_saturationPressureLiquid;

              function der_sublimationPressureIce
                "Derivative of function sublimationPressureIce"
                  extends Modelica.Icons.Function;
                input Modelica.Units.SI.Temperature TSat(displayUnit="degC", nominal=300)
                  "Saturation temperature";
                  input Real dTSat(unit="K/s") "Sublimation temperature derivative";
                  output Real psat_der(unit="Pa/s") "Sublimation pressure derivative";
            protected
                Modelica.Units.SI.Temperature TTriple=273.16 "Triple point temperature";
                Modelica.Units.SI.AbsolutePressure pTriple=611.657 "Triple point pressure";
                  Real r1=TSat/TTriple "Common subexpression 1";
                  Real r1_der=dTSat/TTriple "Derivative of common subexpression 1";
                  Real a[2]={-13.9281690,34.7078238} "Coefficients a[:]";
                  Real n[2]={-1.5,-1.25} "Coefficients n[:]";
              algorithm
                  psat_der := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*pTriple*(-(a[1]
                    *(r1^(n[1] - 1)*n[1]*r1_der)) - (a[2]*(r1^(n[2] - 1)*n[2]*r1_der)));
                  annotation (
                    Inline=false,
                    smoothOrder=5,
                    Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://IBPSA.Utilities.Psychrometrics.Functions.sublimationPressureIce\">
IBPSA.Utilities.Psychrometrics.Functions.sublimationPressureIce</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 12, 2020, by Michael Wetter:<br/>
Change name of argument <code>dTsat</code> to <code>dTSat</code> for consistency
with
<a href=\"modelica://IBPSA.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid\">
IBPSA.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid</a>.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IBPSA.Media</code>.
</li>
</ul>
</html>"));
              end der_sublimationPressureIce;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Utilities.Psychrometrics.Functions\">IBPSA.Utilities.Psychrometrics.Functions</a>.
</p>
</html>"));
            end BaseClasses;
            annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for psychrometric calculations.
</p>

The nomenclature used in this package is described at
<a href=\"modelica://IBPSA.UsersGuide.Conventions\">
IBPSA.UsersGuide.Conventions</a>.
</html>"));
          end Functions;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for psychrometric calculations.
</p>
<p>
The nomenclature used in this package is described at
<a href=\"modelica://IBPSA.UsersGuide.Conventions\">
IBPSA.UsersGuide.Conventions</a>.
</p>
</html>"));
        end Psychrometrics;
      annotation (
      preferredView="info", Documentation(info="<html>
<p>
This package contains utility models such as for thermal comfort calculation, input/output, co-simulation, psychrometric calculations and various functions that are used throughout the library.
</p>
</html>"),
      Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
          Polygon(
            origin={1.3835,-4.1418},
            rotation=45.0,
            fillColor={64,64,64},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
            points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
          Polygon(
            origin={10.1018,5.218},
            rotation=-45.0,
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
      end Utilities;
    annotation (
    versionDate="2018-09-28",
    dateModified = "2018-09-28",
    conversion(from(version="3.0.0",
                    script="modelica://IBPSA/Resources/Scripts/Conversion/ConvertIBPSA_from_3.0_to_4.0.mos")),
    preferredView="info",
    Documentation(info="<html>
<p>
<img
align=\"right\"
alt=\"Logo of IBPSA\"
src=\"modelica://IBPSA/Resources/Images/IBPSA-logo-text.png\" border=\"1\"/>
The <code>IBPSA</code> library is a free library
that provides more than 300 classes (models, functions, etc.) for the development of
Modelica libraries for building and community energy and control systems.
The library is compatible with models from the Modelica Standard Library,
in particular with models from
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a>
and
<a href=\"modelica://Modelica.Media\">Modelica.Media</a>.
</p>
<p>
The development of the IBPSA library is organized through the
<a href=\"https://ibpsa.github.io/project1\">IBPSA Project 1</a>
of the International Building Performance Simulation Association (IBPSA).
From 2012 to 2017, the development was organized through the
<a href=\"http://www.iea-annex60.org\">Annex 60 project</a>
of the Energy in Buildings and Communities Programme of the International Energy Agency (IEA EBC).
</p>
<p>
The intent of the library is that it will be extended by
implementations of Modelica libraries that are targeted to end-users.
Major goals are
</p>
<ul>
<li>to codify best practice and to provide a solid foundation onto which
other libraries for building and community energy systems can be built, and
</li>
<li>
to avoid a fragmentation of libraries that serve similar purpose but
that cannot share models among each others, thereby duplicating efforts
for model development and validation.
</li>
</ul>
<p>
Hence, this library is typically not used directly by end-users,
but rather by developers of libraries that will be distributed to end-users.
Libraries that are using the <code>IBPSA</code> library as their core, or
that are working on using the <code>IBPSA</code> as their core, include, in
alphabetic order:
</p>
<ul>
<li>
The <code>AixLib</code> library from RWTH Aachen, Germany, available at
<a href=\"https://github.com/RWTH-EBC/AixLib\">https://github.com/RWTH-EBC/AixLib</a>
</li>
<li>
The <code>Buildings</code> library from Lawrence Berkeley National Laboratory, Berkeley, CA, available at
<a href=\"http://simulationresearch.lbl.gov/modelica\">http://simulationresearch.lbl.gov/modelica/</a>.
</li>
<li>
The <code>BuildingSystems</code> library from
Universit&auml;t der K&uuml;nste Berlin, Germany,
available at
<a href=\"http://www.modelica-buildingsystems.de/\">http://www.modelica-buildingsystems.de/</a>.
</li>
<li>
The <code>IDEAS</code> library from KU Leuven, Belgium, available at
<a href=\"https://github.com/open-ideas/IDEAS\">https://github.com/open-ideas/IDEAS</a>.
</li>
</ul>
<p>
The library also contains more than 300 example and validation models. For Dymola,
each of these example and validation models contains a script that simulates it and
plots certain variables of interest.
</p>
<p>
The web page for this library is
<a href=\"https://github.com/ibpsa/modelica\">https://github.com/ibpsa/modelica</a>.
Contributions to further advance the library are welcomed.
Contributions may not only be in the form of model development, but also
through model use, model testing and validation,
requirements definition or providing feedback regarding the model applicability
to solve specific problems.
</p>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
            graphics={Bitmap(extent={{-90,-90},{90,90}},
            fileName="modelica://ETAFactorySimulationLib/Resources/Images/IBPSA-logo.png")}));
    end IBPSA;
  annotation (Documentation(info="<html>
<p>The core package integrates definite versions of external open source model libraries which are used in the <span style=\"font-family: Courier New;\">ETAFactorySimulationLib</span> (see also <a href=\"modelica://ETAFactorySimulationLib.UsersGuide.Acknowledgments\">Acknowledgments</a>).</p>
<p><br><b>IMPORTANT:</b> This package contains specific versions of external libraries and should not be edited. Therfore, the core package has been locked. Please do NOT unlock or change/add any models! </p><p><br>If the core has to be temporary unlocked, locking the core again requires manual changes within the package.mo file using the text editor. Therefore, the command <i>__Dymola_LockedEditing=&quot;The core package contains external libraries which should not be edited. Do NOT unlock!&quot;</i> has to be added to the annotation. </p>
</html>"));
  end Core;

  package ProductionSystems "Package containing models of industrial production machines"
     extends ETAFactorySimulationLib.BaseClasses.Icons.ProductionSystems;

    package CleaningMachines
        extends ETAFactorySimulationLib.BaseClasses.Icons.CleaningMach;

      package Test "Test models of cleaning machines"
      extends .ETAFactorySimulationLib.BaseClasses.Icons.Test;

        model Test_ThroughputCleaningSystem_Frank "Test model for ThroughputCleaningSystem"
          extends ETAFactorySimulationLib.BaseClasses.Icons.Test;

            package Medium_MoistAir =
              Modelica.Media.Air.MoistAir (          T_default=297.15,X_default={0.007,0.993}) "Medium (Water) in the component";

            package Medium_Water =
              Modelica.Media.Water.ConstantPropertyLiquidWater (
               T_default=297.15) "Medium (Air) in the component";

          Modelica.Blocks.Sources.CombiTimeTable m_flow_VaporizedWater_CleaningZone(
            table=[0.0,0.0; 3000,0.0112],
            smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments,
            extrapolation=Modelica.Blocks.Types.Extrapolation.HoldLastPoint)
            annotation (Placement(transformation(extent={{-100,4},{-80,24}})));

          Modelica.Blocks.Sources.BooleanTable booleanTable_VacuumPump(
            table={3000,3012,3024},
            extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
            startTime=3000)
            annotation (Placement(transformation(extent={{-10,-10},
                    {10,10}},
                rotation=0,
                origin={-90,40})));

          Modelica.Blocks.Sources.CombiTimeTable m_flow_VaporizedWater_WashingZone(
            table=[0.0,0.0; 3000,0.005],
            smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments,
            extrapolation=Modelica.Blocks.Types.Extrapolation.HoldLastPoint)
            annotation (Placement(transformation(extent={{-100,-22},{-80,-2}})));

          Modelica.Blocks.Sources.BooleanTable booleanTable_Pumps(table={
                3000})
            "Unparameterized. Real parameters must be identified!"
            annotation (Placement(transformation(extent={{-100,-50},{-80,-30}})));
          Modelica.Fluid.Sources.FixedBoundary boundary2_CoolingCondenser(
              redeclare package Medium = Medium_Water, nPorts=1)
                        annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={50,10})));
          Modelica.Fluid.Sources.MassFlowSource_T boundary1_CoolingCondenser(
            redeclare package Medium = Medium_Water,
            m_flow=0.3,
            T=288.15,
            nPorts=1) annotation (Placement(
                transformation(extent={{-60,4},{-40,24}})));

          Modelica.Blocks.Sources.CombiTimeTable heat_loss_by_parts(
            table=[0,586; 12,0; 24,586],
            smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments,
            extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
            startTime=3000) "heat loss by heating up the parts"
            annotation (Placement(transformation(extent={{-100,-76},{-80,-56}})));
          Modelica.Thermal.HeatTransfer.Sources.FixedTemperature T_Ambient(T=system.T_ambient)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={90,90})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow HeatLoss_Workpieces(T_ref=297.15)
                            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-48,-50})));
          inner Modelica.Fluid.System system(T_ambient=297.15)
            annotation (Placement(transformation(extent={{-100,-100},{-80,-80}})));
          ThroughputCleaningSystem_Frank throughputCleaningSystem_Frank annotation (Placement(transformation(extent={{-20,-20},{20,20}})));
        equation
          connect(heat_loss_by_parts.y[1],HeatLoss_Workpieces. Q_flow) annotation (Line(points={{-79,-66},{-68,-66},{-68,-50},{-58,-50}},
                                                                                                                                color={0,0,127}));
          connect(throughputCleaningSystem_Frank.Condenser_port_b2, boundary2_CoolingCondenser.ports[1]) annotation (Line(points={{20,12},{36,12},{36,10},{40,10}}, color={0,127,255}));
          connect(throughputCleaningSystem_Frank.heatPort_ambient_temperature, T_Ambient.port) annotation (Line(points={{20,-2},{28,-2},{28,90},{80,90}}, color={191,0,0}));
          connect(boundary1_CoolingCondenser.ports[1], throughputCleaningSystem_Frank.Condenser_port_a2) annotation (Line(points={{-40,14},{-30,14},{-30,12},{-20,12}}, color={0,127,255}));
          connect(HeatLoss_Workpieces.port, throughputCleaningSystem_Frank.heatPort_CleaningTank) annotation (Line(points={{-38,-50},{28,-50},{28,-10},{20,-10}}, color={191,0,0}));
          connect(HeatLoss_Workpieces.port, throughputCleaningSystem_Frank.heatPort_WashingTank) annotation (Line(points={{-38,-50},{28,-50},{28,-18},{20,-18}}, color={191,0,0}));
          connect(m_flow_VaporizedWater_WashingZone.y[1], throughputCleaningSystem_Frank.m_flow_Vaporized_WashingTank) annotation (Line(points={{-79,-12},{-40,-12},{-40,0},{-24,0}}, color={0,0,127}));
          connect(m_flow_VaporizedWater_CleaningZone.y[1], throughputCleaningSystem_Frank.m_flow_VaporizedWater_CleaningTank) annotation (Line(points={{-79,14},{-66,14},{-66,4},{-40,4},{-40,8},{-24,8}}, color={0,0,127}));
          connect(booleanTable_VacuumPump.y, throughputCleaningSystem_Frank.u_VacuumPump) annotation (Line(points={{-79,40},{-32,40},{-32,16},{-24,16}}, color={255,0,255}));
          connect(booleanTable_Pumps.y, throughputCleaningSystem_Frank.u_Pump_CleaningTank) annotation (Line(points={{-79,-40},{-32,-40},{-32,-8},{-24,-8}}, color={255,0,255}));
          connect(booleanTable_Pumps.y, throughputCleaningSystem_Frank.u_Pump_WashingTank) annotation (Line(points={{-79,-40},{-32,-40},{-32,-16},{-24,-16}}, color={255,0,255}));
          annotation (Icon(coordinateSystem(
                  preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            experiment(StopTime=10000, __Dymola_Algorithm=
                 "Dassl"));
        end Test_ThroughputCleaningSystem_Frank;
      end Test;

      package BaseClasses "Base classes for cleaning machines"
        extends ETAFactorySimulationLib.BaseClasses.Icons.Base;

        model CleaningZone
          "Model for cleaning zone"
          import Modelica.Units.SI;

            replaceable package Medium_MoistAir =
              Modelica.Media.Interfaces.PartialMedium "Medium (Water) in the component"
              annotation (choicesAllMatching = true);

             replaceable package Medium_Water =
              Modelica.Media.Interfaces.PartialMedium          "Medium (Air) in the component" annotation (choicesAllMatching = true);


          parameter SI.Volume V_Air = 1 "Air volume";
          parameter SI.Volume V_Water = 1 "Liquid water volume";
          parameter SI.HeatCapacity C = 2500 "Heat capacity of the component - default: 5 kg steel";

          //Pressure loss
          parameter Boolean use_PressureLoss = false "=true to consider pressure losses in component" annotation (Evaluate=true,Dialog(group="Pressure loss"),choices(checkBox=true));
          parameter SI.Pressure dp_nominal=100   "Nominal pressure drop" annotation(Evaluate=true,Dialog(enable=use_PressureLoss, group = "PressureLoss"));
          parameter SI.MassFlowRate m_flow_nominal = 1/3.6 "Nominal mass flow rate" annotation(Evaluate=true,Dialog(group = "PressureLoss"));


          Modelica.Fluid.Interfaces.FluidPort_b port_b(
              redeclare package Medium = Medium_MoistAir)
            annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
          Modelica.Thermal.HeatTransfer.Components.HeatCapacitor
            heatCapacitor(C=C, T(start=Medium_MoistAir.T_default))
                          annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-10,-12})));
          Core.IBPSA.Fluid.FixedResistances.PressureDrop pressureLoss(
            redeclare package Medium = Medium_MoistAir,
            m_flow_nominal=m_flow_nominal,
            dp_nominal=dp_nominal) if use_PressureLoss annotation (Placement(transformation(extent={{12,-10},{32,10}})));
          Modelica.Fluid.Sensors.MassFlowRate
            massFlowRate(redeclare package Medium =
                Medium_MoistAir)
                        annotation (Placement(
                transformation(extent={{42,-10},{62,10}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_a(
              redeclare package Medium = Medium_MoistAir)
            annotation (Placement(transformation(extent={
                    {-110,-10},{-90,10}})));
          Core.IBPSA.Fluid.MixingVolumes.MixingVolumeMoistAir volume_Air(
            redeclare package Medium = Medium_MoistAir,
            m_flow_nominal=m_flow_nominal,
            allowFlowReversal=false,
            V=V_Air,
            nPorts=2) annotation (Placement(transformation(extent={{-10,0},{10,20}})));
          Modelica.Blocks.Interfaces.RealInput
            m_flow_Water annotation (Placement(
                transformation(extent={{-120,70},{-100,90}}), iconTransformation(extent={{-120,70},{-100,90}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow
            prescribedHeatFlow annotation (Placement(
                transformation(extent={{-64,0},{-44,20}})));
          Modelica.Fluid.Vessels.ClosedVolume volume_Water(
            redeclare package Medium = Medium_Water,
            use_portsData=true,
            portsData={Modelica.Fluid.Vessels.BaseClasses.VesselPortsData(diameter=100),Modelica.Fluid.Vessels.BaseClasses.VesselPortsData(diameter=100),Modelica.Fluid.Vessels.BaseClasses.VesselPortsData(diameter=100)},
            use_HeatTransfer=true,
            V=V_Water,
            nPorts=3) annotation (Placement(
                transformation(extent={{4,-80},{24,-60}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_a_Water(
              redeclare package Medium = Medium_Water)
            annotation (Placement(transformation(extent={{90,-90},{110,-70}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b_Water(
              redeclare package Medium = Medium_Water)
            annotation (Placement(transformation(extent={{-110,-90},{-90,-70}})));
          Modelica.Blocks.Math.Product product1
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-70,-30})));
          Modelica.Fluid.Sensors.MassFlowRate
            massFlowRate1(redeclare package Medium =
                Medium_Water) annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-36,-80})));
          Modelica.Fluid.Sources.MassFlowSource_T
            boundary(
            redeclare package Medium = Medium_Water,
            use_m_flow_in=true,
            nPorts=1) annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={54,-36})));
          Modelica.Blocks.Math.Gain gain(k=-1)
            annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=180,
                origin={78,-44})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a
            heatPort annotation (Placement(transformation(
                  extent={{-10,90},{10,110}})));

          Modelica.Thermal.HeatTransfer.Components.ThermalCollector
            thermalCollector(m=3) annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-30,10})));

          Modelica.Thermal.HeatTransfer.Components.ThermalResistor
            thermalResistor(R=0.0005)
                                     "0.002"
                                     annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-26,-38})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort_heatloss_parts
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}}),
                iconTransformation(extent={{-10,-110},{10,-90}})));
          Modelica.Thermal.HeatTransfer.Components.ThermalResistor
            thermalResistor1(R=0.24) annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,70})));
          Modelica.Fluid.Sensors.TemperatureTwoPort senTem_out(redeclare package Medium = Medium_MoistAir) annotation (Placement(transformation(extent={{68,-10},{88,10}})));
          Modelica.Fluid.Sensors.SpecificEnthalpyTwoPort specificEnthalpy(redeclare package Medium = Medium_Water) annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=0,
                origin={-70,-80})));
        equation
          //PressureLoss
          if use_PressureLoss then
            connect(pressureLoss.port_b,massFlowRate.port_a);
            connect(pressureLoss.port_a, volume_Air.ports[
              2]);
          else
            connect(volume_Air.ports[2], massFlowRate.port_a);
          end if;

          connect(volume_Air.ports[1], port_a)
            annotation (Line(points={{-1,0},{-100,0}},
                color={0,127,255}));
          connect(volume_Air.mWat_flow, m_flow_Water)
            annotation (Line(points={{-12,18},{-32,18},{-32,80},{-110,80}},
                                  color={0,0,127}));
          connect(volume_Air.heatPort, heatCapacitor.port)
            annotation (Line(points={{-10,10},{-10,-2}},
                         color={191,0,0}));
          connect(volume_Water.ports[1], massFlowRate1.port_a)
            annotation (Line(points={{12.6667,-80},{-26,-80}},
                             color={0,127,255}));
          connect(product1.y, prescribedHeatFlow.Q_flow)
            annotation (Line(points={{-70,-19},{-70,2},{-72,2},{-72,10},{-64,10}},
                            color={0,0,127}));
          connect(product1.u2, m_flow_Water) annotation (
              Line(points={{-64,-42},{-64,-48},{-90,-48},{-90,80},{-110,80}},
                                       color={0,0,127}));
          connect(boundary.ports[1], volume_Water.ports[2])
            annotation (Line(points={{44,-36},{40,-36},{40,-80},{14,-80}},
                                       color={0,127,255}));
          connect(gain.y, boundary.m_flow_in) annotation (
             Line(points={{71.4,-44},{64,-44}},
                color={0,0,127}));
          connect(gain.u, m_flow_Water) annotation (Line(
                points={{85.2,-44},{100,-44},{100,-20},{38,-20},{38,80},{-110,80}},
                             color={0,0,127}));
          connect(thermalCollector.port_b, volume_Air.heatPort)
            annotation (Line(points={{-20,10},{-10,10}},
                color={191,0,0}));
          connect(thermalCollector.port_a[1],
            prescribedHeatFlow.port) annotation (Line(
                points={{-39.6667,10},{-44,10}},
                                              color={191,
                  0,0}));
          connect(thermalResistor.port_a, volume_Water.heatPort)
            annotation (Line(points={{-26,-48},{-26,-60},{0,-60},{0,-70},{4,-70}},
                              color={191,0,0}));
          connect(thermalResistor.port_b,
            thermalCollector.port_a[2]) annotation (Line(
                points={{-26,-28},{-26,-18},{-40,-18},{-40,10}},
                              color={191,0,0}));
          connect(heatPort_heatloss_parts, volume_Water.heatPort) annotation (Line(
                points={{0,-100},{0,-70},{4,-70}},             color={191,0,0}));
          connect(thermalResistor1.port_b, heatPort)
            annotation (Line(points={{0,80},{0,100}}, color={191,0,0}));
          connect(thermalResistor1.port_a, thermalCollector.port_a[3]) annotation (Line(
                points={{0,60},{0,56},{-76,56},{-76,-4},{-40.3333,-4},{-40.3333,10}},
                                                                    color={191,0,0}));
          connect(senTem_out.port_b, port_b) annotation (Line(points={{88,0},{100,0}}, color={0,127,255}));
          connect(senTem_out.port_a, massFlowRate.port_b) annotation (Line(points={{68,0},{62,0}}, color={0,127,255}));
          connect(volume_Water.ports[3], port_a_Water) annotation (Line(points={{15.3333,-80},{100,-80}}, color={0,127,255}));
          connect(specificEnthalpy.port_a, massFlowRate1.port_b) annotation (Line(points={{-60,-80},{-46,-80}}, color={0,127,255}));
          connect(specificEnthalpy.port_b, port_b_Water) annotation (Line(points={{-80,-80},{-100,-80}}, color={0,127,255}));
          connect(specificEnthalpy.h_out, product1.u1) annotation (Line(points={{-70,-69},{-70,-60},{-76,-60},{-76,-42}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(
                  preserveAspectRatio=false), graphics={                                                                                                                                                                                Text(extent={{-100,-100},{100,-140}},
                                                                                                                                                                                                        lineColor={0,0,0},
                                                                                                                                                                                                        fillColor=
                      {122,255,107},
                    fillPattern=FillPattern.Solid,
                  textString="%name"), Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
                                               Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>Model for cleaning/washing zone in throughput cleaning system.
</p>
<h4>Assumption and limitations</h4>
<p>
This model uses two different mediums - simple liquid water and moist air. The simple liquid water istaken from the cleaning tanks (only vaporized ratio) and the moist air models different zones in the cleaning system.
The vaporized water is extracted from the water cycle and added to the air volume. The thermal resistor between the water and air volume has been parameterized to fit the measurements of the temperature in the air volume of an reference system.
</p>
<h4>Typical use and important parameters</h4>
<p>
It is possible to enble a pressure loss option which requires the nominal values.
</p>
<h4>Validation</h4>
<p>
The model has not been validated yet since the machine is still under construction. Model will be validated after putting the machine into operation.
</p>
<h4>References</h4>
<p>
Despite components from the Modelica Standard library, the \"MixingVolumeMoistAir\" from Buildings library (s. Core) was used.
</p>
</html>"));
        end CleaningZone;

        model DryingZone
          "Model for drying zone"
          import Modelica.Units.SI;

            replaceable package Medium =
              Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choicesAllMatching = true);

          parameter SI.Volume V = 1 "Volume in cleaning zone";
          parameter SI.HeatCapacity C = 2500 "Heat capacity of the component - default: 5 kg steel";

          //Pressure loss
          parameter Boolean use_PressureLoss = false "=true to consider pressure losses in component" annotation (Evaluate=true,Dialog(group="Pressure loss"),choices(checkBox=true));
          parameter SI.Pressure dp_nominal=100   "Nominal pressure drop" annotation(Evaluate=true,Dialog(enable=use_PressureLoss, group = "PressureLoss"));
          parameter SI.MassFlowRate m_flow_nominal = 1/3.6 "Nominal mass flow rate" annotation(Evaluate=true,Dialog(enable=use_PressureLoss, group = "PressureLoss"));

          Modelica.Fluid.Interfaces.FluidPort_a port_a(
              redeclare package Medium = Medium)
            annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b(
              redeclare package Medium = Medium)
            annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
          Modelica.Thermal.HeatTransfer.Components.HeatCapacitor
            heatCapacitor(C=C, T(start=Medium.T_default))
                          annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-30,-50})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a T_Ambient
            annotation (Placement(transformation(extent={{-10,90},{10,110}})));
          Core.IBPSA.Fluid.FixedResistances.PressureDrop pressureLoss(
            redeclare package Medium = Medium,
            m_flow_nominal=m_flow_nominal,
            dp_nominal=dp_nominal) if use_PressureLoss annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          Core.IBPSA.Fluid.Sensors.Temperature senTem_in(redeclare package Medium = Medium) annotation (Placement(transformation(extent={{-90,20},{-70,40}})));
          Modelica.Fluid.Sensors.MassFlowRate
            massFlowRate(redeclare package Medium =
                Medium) annotation (Placement(
                transformation(extent={{32,-10},{52,10}})));
          Modelica.Fluid.Vessels.ClosedVolume volume(
            redeclare package Medium = Medium,
            p_start=Medium.p_default,
            T_start=Medium.T_default,
            use_portsData=false,
            use_HeatTransfer=true,
            V=V,
            nPorts=2) annotation (Placement(
                transformation(extent={{-10,0},{10,20}})));
          Modelica.Thermal.HeatTransfer.Components.ThermalResistor
            thermalResistor1(R=0.24) annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,62})));
          Modelica.Fluid.Sensors.TemperatureTwoPort senTem_out(redeclare package Medium = Medium) annotation (Placement(transformation(extent={{64,-10},{84,10}})));
        equation
          //PressureLoss
          if use_PressureLoss then
            connect(port_a,pressureLoss.port_a);
            connect(pressureLoss.port_b,volume.ports[1]);
          else
            connect(port_a,volume.ports[1]);
          end if;


          connect(senTem_in.port, port_a) annotation (
              Line(points={{-80,20},{-80,0},{-100,0}},
                color={0,127,255}));
          connect(volume.ports[2], massFlowRate.port_a)
            annotation (Line(points={{1,0},{32,0}}, color=
                 {0,127,255}));
          connect(heatCapacitor.port, volume.heatPort)
            annotation (Line(points={{-30,-40},{-32,-40},{
                  -32,10},{-10,10}}, color={191,0,0}));
          connect(T_Ambient, T_Ambient)
            annotation (Line(points={{0,100},{0,100}}, color={191,0,0}));
          connect(thermalResistor1.port_b, T_Ambient)
            annotation (Line(points={{0,72},{0,100}}, color={191,0,0}));
          connect(thermalResistor1.port_a, volume.heatPort) annotation (Line(points={{
                  -6.66134e-16,52},{0,52},{0,30},{-18,30},{-18,10},{-10,10}}, color={
                  191,0,0}));
          connect(senTem_out.port_b, port_b) annotation (Line(points={{84,0},{100,0}}, color={0,127,255}));
          connect(massFlowRate.port_b, senTem_out.port_a) annotation (Line(points={{52,0},{64,0}}, color={0,127,255}));
          annotation (Icon(coordinateSystem(
                  preserveAspectRatio=false), graphics={                                                                                                                                                                                Text(extent={{-100,-100},{100,-140}},
                                                                                                                                                                                                        lineColor={0,0,0},
                                                                                                                                                                                                        fillColor=
                      {122,255,107},
                    fillPattern=FillPattern.Solid,
                  textString="%name"), Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
                                               Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>Model for drying zone in throughput cleaning system.
</p>
<h4>Assumption and limitations</h4>
<p>
This model uses moist air as medium and consists of a volume to transfer heat from the medium.
</p>
<h4>Typical use and important parameters</h4>
<p>
It is possible to enble a pressure loss option which requires the nominal values.
</p>
<h4>Validation</h4>
<p>
The model has not been validated yet since the machine is still under construction. Model will be validated after putting the machine into operation.
</p>
<h4>References</h4>
<p>
All components used are taken from the Modelica Standard library.
</p>
</html>"));
        end DryingZone;

        model CleaningTank_Reference
          "Model of electrical heated tank with cleaning medium with connection to thermal network"
          import Modelica.Units.SI;
          import Modelica.Units.NonSI;

          //##PARAMETERS##
          replaceable package Medium =
              Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choicesAllMatching = true);

          // Tank geometry
          parameter SI.Height height "Height of tank";
          parameter SI.Area crossArea "Area of tank";
          parameter SI.Length length "Length"  annotation(Dialog(group="heatexchanger pipe"));
          parameter SI.Diameter diameter "Diameter of circular pipe" annotation(Dialog(group="heatexchanger pipe"));

          //Pump
          parameter SI.MassFlowRate m_flow_nom = 1/3.6 "Nominal mass flow rate" annotation (Dialog(group="Pump"));
          parameter SI.Power P_el_nom_Pump = 300 "Nomnal electrical power" annotation (Dialog(group="Pump"));

          //Immersion heater
          parameter SI.Temperature T_low=333.15   "Temperature for switching on heater" annotation (Dialog(group="Immersion heater"));
          parameter SI.Temperature T_high=338.15   "Temperature for switching off heater" annotation (Dialog(group="Immersion heater"));
          parameter SI.Power P_el_nom = 1000 "Nominal power" annotation (Dialog(group="Immersion heater"));

          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor
            temperatureSensor1 annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-30,-50})));

          Modelica.Thermal.HeatTransfer.Components.ThermalCollector
            thermalCollector(m=2) annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={58,-52})));

          Modelica.Blocks.Sources.Constant const(k=(T_high
                 + T_low)/2)
            annotation (Placement(transformation(extent={{-100,
                    -30},{-80,-10}})));

          Modelica.Fluid.Vessels.OpenTank tank(
            height=height,
            crossArea=crossArea,
            level_start=0.9*height,
            redeclare package Medium = Medium,
            use_portsData=false,
            use_HeatTransfer=true,
            nPorts=3) annotation (Placement(
                transformation(extent={{52,0},{92,40}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_a(
              redeclare package Medium = Medium)
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}}),
                iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b(
              redeclare package Medium = Medium)
            annotation (Placement(transformation(extent={{90,-10},{110,10}}),
                iconTransformation(extent={{90,-10},{110,10}})));
          Modelica.Fluid.Interfaces.FluidPort_a
            port_a_Condensate(redeclare package Medium =
                Medium) annotation (Placement(
                transformation(extent={{-110,70},{-90,90}}),iconTransformation(extent={{-110,70},{-90,90}})));
          Components.Pumps.IdealPump pump_simple(
            redeclare package Medium = Medium,
            addPowerLossToMedium=false,
            m_flow_nom=m_flow_nom,
            P_el_nom=P_el_nom_Pump) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,70})));
          Modelica.Blocks.Math.BooleanToReal
            booleanToReal1
                          annotation (Placement(
                transformation(extent={{2,30},{22,50}})));
          Modelica.Blocks.Interfaces.BooleanInput u_Pump
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=0,
                origin={-120,30}),
                                 iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-110,40})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a T_Ambient annotation (
              Placement(transformation(extent={{90,-70},{110,-50}}), iconTransformation(
                  extent={{90,-70},{110,-50}})));
          Modelica.Thermal.HeatTransfer.Components.ThermalResistor thermalResistor_tank_to_ambient(R=0.424)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={80,-68})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow
            preHeatFlow annotation (Placement(
                transformation(extent={{20,-30},{40,-10}})));
          Modelica.Blocks.Continuous.LimPID PI_Heater(
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            k=0.1,
            yMax=1,
            yMin=0) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-50,-20})));

          Modelica.Blocks.Math.Gain gain(k=P_el_nom)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-14,-20})));
          Modelica.Blocks.Interfaces.RealOutput P_el
            annotation (Placement(transformation(extent={
                    {100,80},{120,100}})));
          Modelica.Blocks.Math.Add add annotation (
              Placement(transformation(extent={{72,80},{
                    92,100}})));
        equation
          connect(port_a, tank.ports[1]) annotation (Line(
                points={{-100,0},{50,0},{50,50},{82,50},{82,0},{69.3333,0}},
                       color={0,127,255}));
          connect(tank.ports[2], port_a_Condensate)
            annotation (Line(points={{72,0},{72,8},{-58,8},{-58,80},{-100,80}},
                color={0,127,255}));
          connect(port_b, pump_simple.port_b) annotation (
             Line(points={{100,0},{100,44},{44,44},{44,54},{36,54},{36,62},{30,62},{30,86},{50,86},{50,80}},
                            color={0,127,255}));
          connect(pump_simple.port_a, tank.ports[3])
            annotation (Line(points={{50,60},{50,50},{74.6667,50},{74.6667,0}},
                                    color={0,127,255}));
          connect(booleanToReal1.y, pump_simple.u)
            annotation (Line(points={{23,40},{38,40},{38,70}},
                color={0,0,127}));
          connect(u_Pump, booleanToReal1.u) annotation (Line(points={{-120,30},{-60,30},{-60,40},{0,40}},
                                    color={255,0,255}));
          connect(temperatureSensor1.port, tank.heatPort) annotation (Line(points={{-20,-50},{16,-50},{16,-34},{52,-34},{52,20}},
                                                                    color={191,0,0}));
          connect(T_Ambient, thermalResistor_tank_to_ambient.port_a)
            annotation (Line(points={{100,-60},{100,-68},{90,-68}}, color={191,0,0}));
          connect(thermalCollector.port_b, tank.heatPort) annotation (Line(points={{68,-52},{76,-52},{76,-34},{52,-34},{52,20}},
                                                                    color={191,0,0}));
          connect(preHeatFlow.port, thermalCollector.port_a[
            1]) annotation (Line(points={{40,-20},{48.25,-20},{48.25,-52}},
                               color={191,0,0}));
          connect(PI_Heater.u_s, const.y) annotation (
              Line(points={{-62,-20},{-79,-20}}, color={0,
                  0,127}));
          connect(temperatureSensor1.T, PI_Heater.u_m)
            annotation (Line(points={{-41,-50},{-50,-50},{-50,-32}},
                              color={0,0,127}));
          connect(PI_Heater.y, gain.u) annotation (Line(
                points={{-39,-20},{-26,-20}}, color={0,0,
                  127}));
          connect(gain.y, preHeatFlow.Q_flow) annotation (
             Line(points={{-3,-20},{20,-20}}, color={0,0,
                  127}));
          connect(add.y, P_el) annotation (Line(points={{
                  93,90},{110,90}}, color={0,0,127}));
          connect(add.u2, pump_simple.P_el) annotation (
              Line(points={{70,84},{47,84},{47,81}},
                color={0,0,127}));
          connect(add.u1, preHeatFlow.Q_flow) annotation (
             Line(points={{70,96},{8,96},{8,-20},{20,-20}},
                color={0,0,127}));
          connect(thermalResistor_tank_to_ambient.port_b, thermalCollector.port_a[2]) annotation (Line(points={{70,-68},{47.75,-68},{47.75,-52}}, color={191,0,0}));
          annotation (Icon(coordinateSystem(
                  preserveAspectRatio=false), graphics={                                                                                                                                                                                  Text(extent={{-100,-100},{100,-140}},
                                                                                                                                                                                                        lineColor={0,0,0},
                                                                                                                                                                                                        fillColor=
                      {122,255,107},
                    fillPattern=FillPattern.Solid,
                  textString="%name"), Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
                                               Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>Model for cleaning/washing tank in throughput cleaning system - No heat recovery system, only immersion heater.
</p>
<h4>Assumption and limitations</h4>
<p>
This model uses simple liquid water as medium and a tank which can be heated by an immersion heater. A simple pump from ETAFactorySimulationLib is used for pumping water into the cleaning zone (Can be switched on/off by boolean signal). Heat losses to environment are considered.
</p>
<h4>Validation</h4>
<p>
The model has not been validated yet since the machine is still under construction. Model will be validated after putting the machine into operation.
</p>
<h4>References</h4>
<p>
All components used are from the Modelica Standard library or the ETAFactorySimulationLib. For further information, see the documentation of the sub-components.
</p>
</html>"));
        end CleaningTank_Reference;

        model Condenser "Model for condenser"
        import Modelica.Units.SI;

            replaceable package Medium_MoistAir = Modelica.Media.Air.MoistAir constrainedby Modelica.Media.Interfaces.PartialMedium
                                                      "Medium (Air) in the component"
              annotation (choicesAllMatching = true);

             replaceable package Medium_Water = Modelica.Media.Water.ConstantPropertyLiquidWater constrainedby Modelica.Media.Interfaces.PartialMedium
                                                               "Medium (Water) in the component" annotation (choicesAllMatching = true);

          //## PARAMETERS, VARIABLES and CONSTANTS ##
          parameter SI.Volume V1 = 1 "Volume stream 1";
          parameter SI.Volume V2 = 1 "Volume stream 2";
          parameter SI.CoefficientOfHeatTransfer U=300;
          parameter SI.Area A = 5 "Heat Exchange Area [m^2]";
          parameter Boolean allowFlowReversal=true "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports.";

          SI.Efficiency eps;
          SI.Efficiency NTU;
          Medium_MoistAir.Temperature T_in1 "Inlet temperature medium 1";
          Medium_Water.Temperature T_in2 "Inlet temperature medium 2";
          SI.ThermalConductance C1_flow "Heat capacity flow rate medium 1";
          SI.ThermalConductance C2_flow "Heat capacity flow rate medium 2";
          SI.ThermalConductance CMax_flow(min=0);
          SI.ThermalConductance CMin_flow(min=0);
          SI.HeatFlowRate QMax_flow "Maximum heat flow rate into medium 1";
          SI.HeatFlowRate Q_flow;
          constant Real e=Modelica.Math.exp(1.0);

          //Pressure loss
          parameter Boolean use_PressureLoss = false "=true to consider pressure losses in component" annotation (Evaluate=true,Dialog(group="Pressure loss"),choices(checkBox=true));
          parameter SI.Pressure dp_nominal_1=100   "Nominal pressure drop 1" annotation(Evaluate=true,Dialog(enable=use_PressureLoss, group = "PressureLoss"));
          parameter SI.MassFlowRate m_flow_nominal_1 = 1/3.6 "Nominal mass flow rate 1" annotation(Evaluate=true,Dialog(group = "PressureLoss"));
          parameter SI.Pressure dp_nominal_2=100   "Nominal pressure drop 2" annotation(Evaluate=true,Dialog(enable=use_PressureLoss, group = "PressureLoss"));
          parameter SI.MassFlowRate m_flow_nominal_2 = 1/3.6 "Nominal mass flow rate 2" annotation(Evaluate=true,Dialog(group = "PressureLoss"));


          Core.IBPSA.Fluid.FixedResistances.PressureDrop pressureLoss1(
            redeclare package Medium = Medium_MoistAir,
            m_flow_nominal=m_flow_nominal,
            dp_nominal=dp_nominal) if use_PressureLoss annotation (Placement(transformation(extent={{20,50},{40,70}})));
          Modelica.Fluid.Sensors.MassFlowRate massFlowRate1(redeclare package Medium = Medium_MoistAir)
            annotation (Placement(transformation(extent={{
                    60,50},{80,70}})));
          Core.IBPSA.Fluid.MixingVolumes.MixingVolumeMoistAir volume_Air(
            redeclare package Medium = Medium_MoistAir,
            m_flow_nominal=m_flow_nominal_1,
            V=V1,
            nPorts=3) annotation (Placement(transformation(extent={{-10,60},{10,80}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow
            preHeatFlow1 annotation (Placement(
                transformation(extent={{-60,-2},{-40,18}})));
          Modelica.Fluid.Vessels.ClosedVolume volume_Water(
            redeclare package Medium = Medium_Water,
            use_portsData=false,
            use_HeatTransfer=true,
            V=V2,
            nPorts=3) annotation (Placement(
                transformation(extent={{-10,-60},{10,-40}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b1(redeclare package Medium = Medium_MoistAir)
            annotation (Placement(transformation(extent={{
                    90,50},{110,70}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_a1(redeclare package Medium = Medium_MoistAir)
            annotation (Placement(transformation(extent={{
                    -110,50},{-90,70}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_a2(
              redeclare package Medium = Medium_Water)
            annotation (Placement(transformation(extent={{
                    90,-70},{110,-50}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b2(
              redeclare package Medium = Medium_Water)
            annotation (Placement(transformation(extent={{
                    -110,-70},{-90,-50}})));
          Core.IBPSA.Fluid.FixedResistances.PressureDrop pressureLoss2(
            redeclare package Medium = Medium_Water,
            m_flow_nominal=m_flow_nominal,
            dp_nominal=dp_nominal) if use_PressureLoss annotation (Placement(transformation(extent={{20,-70},{40,-50}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow
            preHeatFlow2 annotation (Placement(
                transformation(extent={{-60,-22},{-40,-2}})));
          Modelica.Fluid.Sensors.MassFlowRate massFlowRate2(redeclare package Medium = Medium_Water)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={70,-60})));

          Modelica.Blocks.Sources.Constant const(k=0.75)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={82,10})));
          Modelica.Blocks.Interfaces.RealOutput mWat_Flow
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={110,30})));

          Modelica.Fluid.Sensors.Temperature temperature(redeclare package Medium = IBPSA.Media.Water)
            annotation (Placement(transformation(
                extent={{10,-10},{-10,10}},
                rotation=180,
                origin={30,-30})));
          Modelica.Blocks.Interfaces.RealOutput T_Water
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={110,-30})));
          Modelica.Blocks.Continuous.LimPID PI_Condensation(
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            k=0.1,
            yMax=0,
            yMin=-0.5) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={42,10})));
          IBPSA.Fluid.Sensors.RelativeHumidity senRelHum(redeclare package Medium = Medium_MoistAir, warnAboutOnePortConnection=false) annotation (Placement(transformation(extent={{8,22},{28,42}})));
      protected
          Medium_MoistAir.ThermodynamicState state_a1_inflow=
            Medium_MoistAir.setState_phX(port_a1.p, inStream(port_a1.h_outflow), inStream(port_a1.Xi_outflow))
            "state for medium inflowing through port_a1";
          Medium_Water.ThermodynamicState state_a2_inflow=
            Medium_Water.setState_phX(port_a2.p, inStream(port_a2.h_outflow), inStream(port_a2.Xi_outflow))
            "state for medium inflowing through port_a2";

        equation
          //PressureLoss
          if use_PressureLoss then
            connect(pressureLoss1.port_b,massFlowRate1.port_a);
            connect(pressureLoss1.port_a, volume_Air.ports[2]);
            connect(pressureLoss2.port_b,massFlowRate2.port_a);
            connect(pressureLoss2.port_a, volume_Water.ports[2]);
          else
            connect(volume_Air.ports[2], massFlowRate1.port_a);
            connect(volume_Water.ports[2], massFlowRate2.port_a);
          end if;

          T_in1 = Medium_MoistAir.temperature(state_a1_inflow);
          T_in2 = Medium_Water.temperature(state_a2_inflow);
          C1_flow = abs(port_a1.m_flow)* Medium_MoistAir.specificHeatCapacityCp(state_a1_inflow);
          C2_flow = abs(port_a2.m_flow)* Medium_Water.specificHeatCapacityCp(state_a2_inflow);
          CMin_flow = min(C1_flow, C2_flow);
          CMax_flow = max(C1_flow, C2_flow);
          QMax_flow = CMin_flow*(T_in2 - T_in1);

          if Modelica.Math.isEqual(CMin_flow,0.0) == true then
            NTU = 0;
            eps = 1;
          elseif Modelica.Math.isEqual(CMin_flow/CMax_flow,1.0) == true then
            NTU = U*A/CMin_flow;
            eps = NTU/(1+NTU);
          else
            NTU = U*A/CMin_flow;
            eps = (1-e^(-(1-CMin_flow/CMax_flow)*NTU))/(1-CMin_flow/CMax_flow*e^(-(1-CMin_flow/CMax_flow)*NTU));
          end if;

          Q_flow = QMax_flow * eps;

          preHeatFlow1.port.Q_flow = -Q_flow-mWat_Flow*2257000;
          preHeatFlow2.port.Q_flow = +Q_flow+mWat_Flow*2257000;


          connect(massFlowRate1.port_b, port_b1)
            annotation (Line(points={{80,60},{100,60}},
                color={0,127,255}));
          connect(volume_Air.ports[1], port_a1)
            annotation (Line(points={{-1.33333,60},{-100,60}},
                color={0,127,255}));
          connect(preHeatFlow1.port, volume_Air.heatPort)
            annotation (Line(points={{-40,8},{-10,8},{-10,
                  70}}, color={191,0,0}));
          connect(preHeatFlow2.port, volume_Water.heatPort)
            annotation (Line(points={{-40,-12},{-10,-12},{
                  -10,-50}}, color={191,0,0}));
          connect(volume_Water.ports[1], port_b2)
            annotation (Line(points={{-1.33333,-60},{-100,-60}},
                color={0,127,255}));
          connect(massFlowRate2.port_a, port_a2)
            annotation (Line(points={{80,-60},{100,-60}},
                color={0,127,255}));
          connect(mWat_Flow, volume_Air.mWat_flow)
            annotation (Line(points={{110,30},{88,30},{88,80},{-12,80},{-12,78}},
                        color={0,0,127}));
          connect(temperature.T, T_Water) annotation (
              Line(points={{37,-30},{70,-30},{70,-30},{110,-30}},
                                                  color={
                  0,0,127}));
          connect(const.y, PI_Condensation.u_s)
            annotation (Line(points={{71,10},{54,10}}, color={0,0,127}));
          connect(PI_Condensation.y, volume_Air.mWat_flow) annotation (Line(points={{31,
                  10},{8,10},{8,40},{-32,40},{-32,78},{-12,78}}, color={0,0,127}));
          connect(senRelHum.phi, PI_Condensation.u_m) annotation (Line(points={{29,32},{42,32},{42,22}}, color={0,0,127}));
          connect(senRelHum.port, volume_Air.ports[3]) annotation (Line(points={{18,22},{18,20},{0,20},{0,60},{1.33333,60}}, color={0,127,255}));
          connect(temperature.port, volume_Water.ports[3]) annotation (Line(points={{30,-20},{14,-20},{14,-60},{1.33333,-60}}, color={0,127,255}));
          annotation (Icon(coordinateSystem(
                  preserveAspectRatio=false), graphics={
                Rectangle(extent={{-164,26},{-164,26}},
                    lineColor={28,108,200}),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                                                                                                                                                                       Text(extent={{-100,-100},{100,-140}},
                                                                                                                                                                                                        lineColor={0,0,0},
                                                                                                                                                                                                        fillColor=
                      {122,255,107},
                    fillPattern=FillPattern.Solid,
                  textString="%name")}),       Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>Model for condenser in throughput cleaning system
</p>
<h4>Assumption and limitations</h4>
<p>
This model uses two different mediums - simple liquid water and moist air. Heat is transferred from the water volume to the air volume to condense the water in the air. The mass flow rate of the condensate is controlled by a setpoint of relative humidity of 75 % for the leaving air.
</p>
<h4>Validation</h4>
<p>
The model has not been validated yet since the machine is still under construction. Model will be validated after putting the machine into operation.
</p>
<h4>References</h4>
<p>
All components used are from the Modelica Standard library and the Buildings library (s. Core).
</p>
</html>"));
        end Condenser;

        model ControlVentilation
          Modelica.Blocks.Continuous.FirstOrder firstOrder_Ventilation(T=30/5)
            "Unparameterized! T must be identified!"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={64,0})));
          Modelica.Blocks.Sources.Constant setpoint_rel_humidity(k=0.4) annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-30,30})));
          Modelica.Blocks.Continuous.LimPID PI_Ventilation(
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            k=0.01,
            yMax=0,
            yMin=-1) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={8,0})));
          Modelica.Blocks.Math.Gain gain(k=-1)
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={36,0})));
          Modelica.Blocks.Interfaces.RealOutput y1
                       "Connector of Real output signal" annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput u_m1
                        "Connector of measurement input signal" annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        equation
          connect(PI_Ventilation.u_s,setpoint_rel_humidity. y)
            annotation (Line(points={{-4,0},{-14,0},{-14,30},{-19,30}},
                                                             color={0,0,127}));
          connect(PI_Ventilation.y,gain. u) annotation (
              Line(points={{19,0},{24,0}},         color=
                  {0,0,127}));
          connect(gain.y,firstOrder_Ventilation. u)
            annotation (Line(points={{47,0},{52,0}},
                color={0,0,127}));
          connect(firstOrder_Ventilation.y, y1) annotation (Line(points={{75,0},{110,0}}, color={0,0,127}));
          connect(PI_Ventilation.u_m, u_m1) annotation (Line(points={{8,-12},{8,-20},{-94,-20},{-94,0},{-120,0}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                                                                                                                                                                       Text(extent={{-100,-100},{100,-140}},
                                                                                                                                                                                                        lineColor={0,0,0},
                                                                                                                                                                                                        fillColor=
                      {122,255,107},
                    fillPattern=FillPattern.Solid,
                  textString="%name")}),            Diagram(coordinateSystem(preserveAspectRatio=false)));
        end ControlVentilation;
      end BaseClasses;

      model ThroughputCleaningSystem_Frank "Simplified model of a throughput cleaning system with 3 zones"

        //## PARAMETERS ##
      replaceable package Medium_MoistAir = ETAFactorySimulationLib.Core.IBPSA.Media.Air constrainedby Modelica.Media.Interfaces.PartialMedium
                                                    "Medium (Air) in the component"
            annotation (choicesAllMatching = true);

           replaceable package Medium_Water = ETAFactorySimulationLib.Core.IBPSA.Media.Water constrainedby Modelica.Media.Interfaces.PartialMedium
                                                             "Medium (Water) in the component" annotation (choicesAllMatching = true);

        ProductionSystems.CleaningMachines.BaseClasses.CleaningZone
          CleaningZone(
          redeclare package Medium_MoistAir =
              Medium_MoistAir,
          redeclare package Medium_Water = Medium_Water,
          V_Air=1.1,
          V_Water=0.001,
          use_PressureLoss=false) annotation (Placement(
              transformation(extent={{-60,-10},{-40,10}})));

        ProductionSystems.CleaningMachines.BaseClasses.CleaningZone
          WashingZone(
          redeclare package Medium_MoistAir =
              Medium_MoistAir,
          redeclare package Medium_Water = Medium_Water,
          V_Air=1.1,
          V_Water=0.001,       use_PressureLoss=false)
          annotation (Placement(transformation(extent={{-30,-10},{-10,10}})));

        BaseClasses.CleaningTank_Reference CleaningTank(
          redeclare package Medium = Medium_Water,
          height=0.5,
          crossArea=1,
          length=5,
          diameter=0.02,
          m_flow_nom=24/3.6,
          P_el_nom_Pump=2.6e3,
          T_low=312.15,
          T_high=314.15,
          P_el_nom=30e3)
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=0,
              origin={-50,-54})));
        BaseClasses.CleaningTank_Reference
                                 WashingTank(
          redeclare package Medium = Medium_Water,
          height=0.5,
          crossArea=1,
          length=5,
          diameter=0.02,
          m_flow_nom=24/3.6,
          P_el_nom_Pump=2.6e3,
          T_low=312.15,
          T_high=314.15,
          P_el_nom=30e3)       annotation (Placement(
              transformation(extent={{-30,-84},{-10,-64}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a
          heatPort_WashingTank annotation (Placement(
              transformation(extent={{90,-100},{110,-80}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a
          heatPort_CleaningTank annotation (Placement(
              transformation(extent={{90,-60},{110,-40}})));
        Modelica.Blocks.Interfaces.BooleanInput
          u_VacuumPump annotation (Placement(
              transformation(
              extent={{-20,-20},{20,20}},
              rotation=0,
              origin={-120,80})));
        Modelica.Fluid.Valves.ValveDiscrete
          valveDiscrete(
          redeclare package Medium = Medium_MoistAir,
          dp_nominal=100000,
          m_flow_nominal=2.77)
          "Unparameterized. Real parameters must be identified!"
                               annotation (Placement(
              transformation(extent={{18,6},{30,-6}})));

        Modelica.Blocks.MathBoolean.Not not1
          annotation (Placement(transformation(
              extent={{-4,-4},{4,4}},
              rotation=180,
              origin={50,-20})));
        BaseClasses.DryingZone dryingZone(redeclare package Medium =
                             Medium_MoistAir,
          V=0.1)
          "Unparameterized. Real parameters must be identified!"
                    annotation (Placement(
              transformation(extent={{36,-10},{56,10}})));

        Modelica.Fluid.Valves.ValveDiscrete
          valveDiscrete1(
          redeclare package Medium = Medium_MoistAir,
          dp_nominal=100000,
          m_flow_nominal=2.77)
          "Unparameterized. Real parameters must be identified!"
                               annotation (Placement(
              transformation(extent={{64,6},{76,-6}})));
        Modelica.Blocks.Interfaces.BooleanInput u_Pump_CleaningTank annotation (
            Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=0,
              origin={-120,-40})));
        Modelica.Blocks.Interfaces.BooleanInput u_Pump_WashingTank annotation (
            Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=0,
              origin={-120,-80})));
        Modelica.Fluid.Sources.FixedBoundary boundary(
            redeclare package Medium = Medium_MoistAir,
            nPorts=1) annotation (Placement(
              transformation(extent={{-90,-10},{-70,10}})));
        Components.Pumps.IdealPump Ventilation(
          redeclare package Medium = Medium_MoistAir,
          addPowerLossToMedium=false,
          m_flow_nom=0.78,
          P_el_nom=1.75e3,
          u_min=0.0) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={56,48})));
        Modelica.Fluid.Sources.FixedBoundary boundary3(
            redeclare package Medium = Medium_MoistAir, nPorts=1)
                      annotation (Placement(
              transformation(extent={{-90,30},{-70,50}})));
        BaseClasses.Condenser condenser(
          redeclare package Medium_MoistAir = Medium_MoistAir,
          redeclare package Medium_Water = Medium_Water,
          V1=0.033,
          V2=0.0059,
          A=19) "Unparameterized! U must be identified!" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={-30,54})));

        Modelica.Fluid.Sources.MassFlowSource_T
          boundary4(
          redeclare package Medium = Medium_Water,
          use_m_flow_in=true,
          use_T_in=true,
          nPorts=1) annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=0,
              origin={-82,-36})));

        Modelica.Fluid.Interfaces.FluidPort_a
          Condenser_port_a2(redeclare package Medium =
              Medium_Water) annotation (Placement(
              transformation(extent={{-110,50},{-90,70}}),    iconTransformation(
                extent={{-110,50},{-90,70}})));
        Modelica.Fluid.Interfaces.FluidPort_b
          Condenser_port_b2(redeclare package Medium =
              Medium_Water) annotation (Placement(
              transformation(extent={{90,50},{110,70}}),      iconTransformation(
                extent={{90,50},{110,70}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort_ambient_temperature
          annotation (Placement(transformation(extent={{90,-20},{110,0}}),
              iconTransformation(extent={{90,-20},{110,0}})));

        Modelica.Blocks.Interfaces.RealOutput temperature_Air_condensator_out1
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=0,
              origin={110,20})));
        Modelica.Blocks.Math.MultiSum multiSum(nu=3)
          annotation (Placement(transformation(extent={{80,74},{92,86}})));
        Modelica.Blocks.Interfaces.RealOutput
          P_el_intern annotation (Placement(
              transformation(extent={{100,70},{120,90}})));
        Modelica.Fluid.Sources.FixedBoundary boundary1(redeclare package Medium = Medium_MoistAir, nPorts=1)
          annotation (Placement(transformation(extent={{-10,-10},
                  {10,10}},
              rotation=180,
              origin={90,0})));
        Modelica.Fluid.Sensors.TemperatureTwoPort temperature(redeclare package Medium = Medium_MoistAir) annotation (Placement(transformation(
              extent={{10,10},{-10,-10}},
              rotation=0,
              origin={-54,40})));
        Modelica.Fluid.Sensors.TemperatureTwoPort temperature2(redeclare package Medium = Medium_MoistAir) annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=0,
              origin={8,48})));
        Modelica.Blocks.Interfaces.RealOutput temperature_Air_condensator_in "Temperature of the passing fluid" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=0,
              origin={110,40})));
        IBPSA.Fluid.Sensors.RelativeHumidityTwoPort senRelHum(redeclare package Medium = Medium_MoistAir, m_flow_nominal=2.77)
                                                                                                          annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=0,
              origin={4,16})));
        BaseClasses.ControlVentilation controlVentilation annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=0,
              origin={30,30})));
        Modelica.Blocks.Interfaces.RealInput m_flow_VaporizedWater_CleaningTank annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
        Modelica.Blocks.Interfaces.RealInput m_flow_Vaporized_WashingTank annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
      equation
         connect(valveDiscrete.open, not1.y) annotation (
           Line(points={{24,-4.8},{24,-20},{45.2,-20}},
              color={255,0,255}));
        connect(dryingZone.port_a, valveDiscrete.port_b)
          annotation (Line(points={{36,0},{30,0}},
              color={0,127,255}));
        connect(dryingZone.port_b, valveDiscrete1.port_a)
          annotation (Line(points={{56,0},{64,0}},
              color={0,127,255}));
        connect(WashingZone.port_a, CleaningZone.port_b)
          annotation (Line(points={{-30,0},{-40,0}},
              color={0,127,255}));
        connect(CleaningZone.port_b_Water,CleaningTank. port_a) annotation (Line(
              points={{-60,-8},{-64,-8},{-64,-54},{-60,-54}},
                                                         color={0,127,255}));
        connect(CleaningZone.port_a_Water,CleaningTank. port_b) annotation (Line(
              points={{-40,-8},{-36,-8},{-36,-54},{-40,-54}},color={0,127,255}));
        connect(CleaningZone.m_flow_Water,
          m_flow_VaporizedWater_CleaningTank)
          annotation (Line(points={{-61,8},{-66,8},{-66,18},{-94,18},{-94,40},{-120,40}},
                                               color={0,
                0,127}));
        connect(CleaningTank.u_Pump, u_Pump_CleaningTank) annotation (Line(points={{-61,-50},{-66,-50},{-66,-40},{-120,-40}},
                                              color={255,0,255}));
        connect(boundary.ports[1], CleaningZone.port_a)
          annotation (Line(points={{-70,0},{-60,0}},
                               color={0,127,255}));
        connect(boundary4.m_flow_in, condenser.mWat_Flow)
          annotation (Line(points={{-92,-28},{-92,51},{-41,51}},
                                      color={0,0,127}));
        connect(boundary4.T_in, condenser.T_Water)
          annotation (Line(points={{-94,-32},{-106,-32},{-106,57},{-41,57}},
                                        color={0,0,127}));
        connect(CleaningTank.port_a_Condensate, boundary4.ports[1]) annotation (Line(
              points={{-60,-46},{-60,-36},{-72,-36}},                   color={0,127,
                255}));
        connect(condenser.port_b2, Condenser_port_b2)
          annotation (Line(points={{-20,60},{100,60}},
                             color={0,127,255}));
        connect(condenser.port_a2, Condenser_port_a2)
          annotation (Line(points={{-40,60},{-100,60}},
                             color={0,127,255}));
        connect(WashingTank.u_Pump, u_Pump_WashingTank) annotation (Line(points={{-31,-70},{-94,-70},{-94,-80},{-120,-80}},
                                       color={255,0,255}));
        connect(heatPort_CleaningTank, CleaningZone.heatPort_heatloss_parts)
          annotation (Line(points={{100,-50},{100,-34},{-50,-34},{-50,-10}},
                                                  color={191,0,0}));
        connect(heatPort_WashingTank, WashingZone.heatPort_heatloss_parts)
          annotation (Line(points={{100,-90},{78,-90},{78,-30},{-20,-30},{-20,-10}},
                                      color={191,0,0}));
        connect(CleaningTank.T_Ambient, heatPort_ambient_temperature) annotation (
            Line(points={{-40,-60},{84,-60},{84,-38},{100,-38},{100,-10}},color={191,
                0,0}));
        connect(CleaningZone.heatPort, heatPort_ambient_temperature) annotation (Line(
              points={{-50,10},{-34,10},{-34,14},{-20,14},{-20,18},{-10,18},{-10,94},{100,94},{100,-10}},
              color={191,0,0}));
        connect(WashingZone.heatPort, heatPort_ambient_temperature) annotation (Line(
              points={{-20,10},{-20,18},{-10,18},{-10,94},{100,94},{100,-10}},
                                                                color={191,0,0}));
        connect(dryingZone.T_Ambient, heatPort_ambient_temperature) annotation (Line(
              points={{46,10},{46,14},{100,14},{100,-10}},
                                                         color={191,0,0}));
        connect(Ventilation.P_el, multiSum.u[1])
          annotation (Line(points={{45,45},{34,45},{34,78.6},{80,78.6}},
                                         color={0,0,127}));
        connect(CleaningTank.P_el, multiSum.u[2])
          annotation (Line(points={{-39,-45},{30,-45},{30,80},{80,80}},
              color={0,0,127}));
        connect(multiSum.y, P_el_intern) annotation (
            Line(points={{93.02,80},{110,80}},   color=
                {0,0,127}));
        connect(u_VacuumPump, not1.u) annotation (Line(
              points={{-120,80},{-12,80},{-12,14},{-6,14},{-6,-6},{0,-6},{0,-24},{42,-24},{42,-28},{62,-28},{62,-20},{55.6,-20}},
                                        color={255,0,
                255}));
        connect(valveDiscrete1.open, not1.u)
          annotation (Line(points={{70,-4.8},{70,-20},{55.6,-20}},
                             color={255,0,255}));
        connect(WashingZone.m_flow_Water,
          m_flow_Vaporized_WashingTank) annotation (
            Line(points={{-31,8},{-36,8},{-36,14},{-94,14},{-94,0},{-120,0}},
              color={0,0,127}));
        connect(P_el_intern, P_el_intern) annotation (
            Line(points={{110,80},{110,80}},   color={0,
                0,127}));
        connect(WashingTank.port_a, WashingZone.port_b_Water)
          annotation (Line(points={{-30,-74},{-34,-74},{-34,-8},{-30,-8}},
                                              color={0,
                127,255}));
        connect(WashingTank.port_b, WashingZone.port_a_Water)
          annotation (Line(points={{-10,-74},{-6,-74},{-6,-8},{-10,-8}},
                                              color={0,
                127,255}));
        connect(WashingTank.T_Ambient,
          heatPort_ambient_temperature) annotation (
            Line(points={{-10,-80},{84,-80},{84,-38},{100,-38},{100,-10}},
                                                  color=
               {191,0,0}));
        connect(WashingTank.P_el, multiSum.u[3])
          annotation (Line(points={{-9,-65},{24,-65},{24,81.4},{80,81.4}},
                                            color={0,0,
                127}));
        connect(valveDiscrete1.port_b, boundary1.ports[1]) annotation (Line(points={{76,0},{80,0}}, color={0,127,255}));
        connect(temperature.port_a, condenser.port_b1) annotation (Line(points={{-44,40},{-40,40},{-40,48}},
                                                                                                     color={0,127,255}));
        connect(temperature.T, temperature_Air_condensator_out1) annotation (Line(points={{-54,29},{-54,16},{-6,16},{-6,12},{32,12},{32,16},{94,16},{94,20},{110,20}},
                                                                                                                 color={0,0,127}));
        connect(condenser.port_a1, temperature2.port_b) annotation (Line(points={{-20,48},{-2,48}},  color={0,127,255}));
        connect(temperature2.port_a, Ventilation.port_b) annotation (Line(points={{18,48},{46,48}},   color={0,127,255}));
        connect(temperature2.T, temperature_Air_condensator_in) annotation (Line(points={{8,59},{8,92},{100,92},{100,40},{110,40}},
                                                                                                                                color={0,0,127}));
        connect(Ventilation.port_a, senRelHum.port_b) annotation (Line(points={{66,48},{66,16},{10,16}},     color={0,127,255}));
        connect(controlVentilation.y1, Ventilation.u) annotation (Line(points={{41,30},{56,30},{56,36}},    color={0,0,127}));
        connect(senRelHum.phi, controlVentilation.u_m1) annotation (Line(points={{4.06,22.6},{4.06,22},{4,22},{4,30},{18,30}},
                                                                                                                           color={0,0,127}));
        connect(CleaningZone.heatPort, WashingZone.heatPort) annotation (Line(points={{-50,10},{-20,10}}, color={191,0,0}));
        connect(WashingZone.port_b, valveDiscrete.port_a) annotation (Line(points={{-10,0},{18,0}},
                                                                                                  color={0,127,255}));
        connect(senRelHum.port_a, valveDiscrete.port_a) annotation (Line(points={{-2,16},{-2,16},{-2,0},{18,0}},
                                                                                                               color={0,127,255}));
        connect(Condenser_port_b2, Condenser_port_b2) annotation (Line(points={{100,60},{100,60}}, color={0,127,255}));
        connect(heatPort_CleaningTank, heatPort_CleaningTank) annotation (Line(points={{100,-50},{100,-50}}, color={191,0,0}));
        connect(temperature.port_b, boundary3.ports[1]) annotation (Line(points={{-64,40},{-70,40}}, color={0,127,255}));
        annotation (Icon(coordinateSystem(
                preserveAspectRatio=false), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={28,108,200},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-100,-102},{100,-140}},
                textColor={0,0,0},
                textString="%name
")}),                                        Diagram(
              coordinateSystem(preserveAspectRatio=false)),
          Documentation(info="<html>
<p>
Reference model for a throughput cleaning machine to be investigated during the resarch project LoTuS - No heat recovery system.
</p>
<h4>Assumption and limitations</h4>
<p>
This model uses two different mediums - simple liquid water and moist air. The simple liquid water is used to model the cleaning tanks and the moist air to model different zones in the cleaning system. The cleaning device consists of two tanks, a cleaning, washing and drying zone as well as 
pump, induction drying ventilation system, condenser (not directloy cooled) and heat recovery system for heting cleaning/washing tank. It is assumed that the machine has open boundries to the environment which means the production hall.
The condensate produced in the condenser is redirected into the tanks with a mass flow source (Needed because of different medium models) and remaining moist air is discharged to the ambient (production hall).
</p>
<h4>Typical use and important parameters</h4>
<p>
As the model consists of lots of different components, propagating their parameters to the top level of the simulation model would be very confusing. Therefore all component parameters are within the simulation model. Note, those parameters result from the product development process during the resarch project LoTus and refer to this specific throughput cleaning system. To simulate any other systems the component parameters hav to checked and adapted.
The relevant input signals to simulate are the following:
- Mass flow rate of vaporized water: To combine different medium models the vaporized water in cleaning and washing zone must be provided.
- Heatports: There two heat ports to consider heat losses through heating up work pieces within the machine and one heatport to consider heat losses to the environment.
- All components are controlled by boolean inputs to switch them on and off.
</p>
<h4>Validation</h4>
<p>
The model has not been validated yet since the machine is still under construction. Model will be validated after putting the machine into operation.
</p>
<h4>References</h4>
<p>
Despite components from the Modelica Standard library, the sub-components extend models from the Buildings library (s. Core). For further information, see the documentation of the sub-components.
</p>
</html>"),          Icon(coordinateSystem(
                preserveAspectRatio=false),
                                     graphics={
              Rectangle(
                extent={{-400,-120},{402,-202}},
                lineColor={153,192,0},
                radius=10,
                fillColor={153,192,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-360,200},{360,-124}},
                lineColor={153,192,0},
                fillColor={153,192,0},
                fillPattern=FillPattern.Solid,
                radius=5),
              Rectangle(
                extent={{-336,122},{-150,-2}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                radius=10),
              Rectangle(
                extent={{-92,122},{94,-2}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                radius=10),
              Rectangle(
                extent={{148,122},{334,-2}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                radius=10),
              Ellipse(
                extent={{-322,30},{-302,10}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-242,68},{-222,48}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-282,68},{-262,48}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-258,32},{-238,12}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-214,30},{-194,10}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-192,56},{-172,36}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-230,46},{-210,26}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-238,36},{-218,16}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-278,42},{-258,22}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-290,46},{-270,26}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-310,70},{-290,50}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-306,82},{-286,62}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-314,44},{-294,24}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-254,54},{-234,34}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-254,64},{-234,44}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-200,64},{-180,44}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-194,32},{-174,12}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-192,20},{-172,0}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-250,14},{-230,-6}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-282,14},{-262,-6}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-292,16},{-272,-4}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-298,4},{-278,24}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-208,12},{-188,-8}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-226,12},{-206,-8}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-24,66},{-4,46}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-36,46},{-16,26}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-46,28},{-26,8}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-72,86},{-52,66}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{10,54},{30,34}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{70,64},{90,44}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{60,22},{80,2}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{34,70},{54,50}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-2,24},{18,4}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-60,44},{-40,24}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{0,102},{20,82}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{-64,64},{-44,44}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{60,82},{80,62}},
                lineColor={153,192,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                lineThickness=1,
                startAngle=0,
                endAngle=360),
              Ellipse(
                extent={{252,58},{236,10}},
                lineColor={135,135,135},
                pattern=LinePattern.None,
                lineThickness=0.5,
                fillColor={153,204,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{252,110},{238,48}},
                lineColor={135,135,135},
                pattern=LinePattern.None,
                lineThickness=0.5,
                fillColor={153,204,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{8,30},{-8,-30}},
                lineColor={135,135,135},
                pattern=LinePattern.None,
                lineThickness=0.5,
                fillColor={153,204,0},
                fillPattern=FillPattern.Solid,
                origin={272,60},
                rotation=90),
              Ellipse(
                extent={{7,29},{-7,-29}},
                lineColor={135,135,135},
                pattern=LinePattern.None,
                lineThickness=0.5,
                fillColor={153,204,0},
                fillPattern=FillPattern.Solid,
                origin={221,59},
                rotation=90)}),              Diagram(
              coordinateSystem(preserveAspectRatio=false)),
          Documentation(info="<html>
<p>
Reference model for a throughput cleaning machine to be investigated during the resarch project LoTuS - No heat recovery system.
</p>
<h4>Assumption and limitations</h4>
<p>
This model uses two different mediums - simple liquid water and moist air. The simple liquid water is used to model the cleaning tanks and the moist air to model different zones in the cleaning system. The cleaning device consists of two tanks, a cleaning, washing and drying zone as well as vacuum pump, induction drying ventilation system, condenser (not directloy cooled) and heat recovery system for heting cleaning/washing tank. It is assumed that the machine has open boundries to the environment which means the production hall.
The condensate produced in the condenser is redirected into the tanks with a mass flow source (Needed because of different medium models) and remaining moist air is discharged to the ambient (production hall).
</p>
<h4>Typical use and important parameters</h4>
<p>
As the model consists of lots of different components, propagating their parameters to the top level of the simulation model would be very confusing. Therefore all component parameters are within the simulation model. Note, those parameters result from the product development process during the resarch project LoTus and refer to this specific throughput cleaning system. To simulate any other systems the component parameters hav to checked and adapted.
The relevant input signals to simulate are the following:
- Mass flow rate of vaporized water: To combine different medium models the vaporized water in cleaning and washing zone must be provided.
- Heatports: There two heat ports to consider heat losses through heating up work pieces within the machine and one heatport to consider heat losses to the environment.
- All components are controlled by boolean inputs to switch them on and off.
</p>
<h4>Validation</h4>
<p>
The model has not been validated yet since the machine is still under construction. Model will be validated after putting the machine into operation.
</p>
<h4>References</h4>
<p>
Despite components from the Modelica Standard library, the sub-components extend models from the Buildings library (s. Core). For further information, see the documentation of the sub-components.
</p>
</html>"));
      end ThroughputCleaningSystem_Frank;
    annotation (Documentation(info="<html>
<p><b><span style=\"font-size: 10pt; color: #008c48;\">References</span></b></p>
<p><a href=\"ETAFactorySimulationLib.UsersGuide.References\">[ELSE21]</a></p>
</html>"));
    end CleaningMachines;
  end ProductionSystems;

  package Utilities "Package containing utilities functions (e.g., statistics, IO, etc.)"
    extends ETAFactorySimulationLib.BaseClasses.Icons.Utilities_Package;

    model PowerN
      extends Modelica.Blocks.Interfaces.SISO;
      parameter Real n;
    equation
      y = abs(u)^n;
      annotation(Diagram(coordinateSystem(                                         preserveAspectRatio = true, initialScale=0.1)));
    end PowerN;
  end Utilities;
annotation (uses(Modelica(version="3.2.3"), DymolaCommands(version="1.9"),
      Complex(version="4.0.0")),             version="0.2",
  Documentation(info="<html>
<h4>ETA Factory Simulation Lib</h4>
</html>"));
end ETAFactorySimulationLib;
